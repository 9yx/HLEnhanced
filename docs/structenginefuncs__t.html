<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Half-Life Enhanced: enginefuncs_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Half-Life Enhanced
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Enhanced Half-Life SDK</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structenginefuncs__t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structenginefuncs__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">enginefuncs_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="eiface_8h_source.html">eiface.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a0b21dbb4e8614ea81d1942636496dd19"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a0b21dbb4e8614ea81d1942636496dd19">pfnPrecacheModel</a> )(const char *pszModelName)</td></tr>
<tr class="separator:a0b21dbb4e8614ea81d1942636496dd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6126faced4799f6dcdc5af7d681240d6"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a6126faced4799f6dcdc5af7d681240d6">pfnPrecacheSound</a> )(const char *pszSoundName)</td></tr>
<tr class="separator:a6126faced4799f6dcdc5af7d681240d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f50bbe622f80f1ecc6faceaf8d8784"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ad2f50bbe622f80f1ecc6faceaf8d8784">pfnSetModel</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEdict, const char *pszModelName)</td></tr>
<tr class="separator:ad2f50bbe622f80f1ecc6faceaf8d8784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7044872292188d6a12b8ceb2b988ccd0"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a7044872292188d6a12b8ceb2b988ccd0">pfnModelIndex</a> )(const char *pszModelName)</td></tr>
<tr class="separator:a7044872292188d6a12b8ceb2b988ccd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812850f1367c910a1a0305719c0d326b"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a812850f1367c910a1a0305719c0d326b">pfnModelFrames</a> )(int modelIndex)</td></tr>
<tr class="separator:a812850f1367c910a1a0305719c0d326b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f58bdfc25e7cff00f86a9fc00041762"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a8f58bdfc25e7cff00f86a9fc00041762">pfnSetSize</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEdict, const <a class="el" href="class_vector.html">Vector</a> &amp;vecMin, const <a class="el" href="class_vector.html">Vector</a> &amp;vecMax)</td></tr>
<tr class="separator:a8f58bdfc25e7cff00f86a9fc00041762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617f7beb26833c0fb4968f351fc8c183"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a617f7beb26833c0fb4968f351fc8c183">pfnChangeLevel</a> )(const char *pszLevelName, const char *pszLandmarkName)</td></tr>
<tr class="separator:a617f7beb26833c0fb4968f351fc8c183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25768848bf9768a692ded928c03fed12"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a25768848bf9768a692ded928c03fed12">pfnGetSpawnParms</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pClient)</td></tr>
<tr class="separator:a25768848bf9768a692ded928c03fed12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be1b1c8dc8d5d379b42fb11750f68d7"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a5be1b1c8dc8d5d379b42fb11750f68d7">pfnSaveSpawnParms</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pClient)</td></tr>
<tr class="separator:a5be1b1c8dc8d5d379b42fb11750f68d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a3b1b2a4a103616d95c62b5c1e322b"><td class="memItemLeft" align="right" valign="top">float(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a92a3b1b2a4a103616d95c62b5c1e322b">pfnVecToYaw</a> )(const <a class="el" href="class_vector.html">Vector</a> &amp;vecVector)</td></tr>
<tr class="separator:a92a3b1b2a4a103616d95c62b5c1e322b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe3e6038bb37b2ed44e8ccf8286c305"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a7fe3e6038bb37b2ed44e8ccf8286c305">pfnVecToAngles</a> )(const <a class="el" href="class_vector.html">Vector</a> &amp;vecIn, <a class="el" href="class_vector.html">Vector</a> &amp;vecOut)</td></tr>
<tr class="separator:a7fe3e6038bb37b2ed44e8ccf8286c305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42a4d33579cd8e6fbd1d23178d5208b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#af42a4d33579cd8e6fbd1d23178d5208b">pfnMoveToOrigin</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity, const <a class="el" href="class_vector.html">Vector</a> &amp;vecGoal, float dist, int iMoveType)</td></tr>
<tr class="separator:af42a4d33579cd8e6fbd1d23178d5208b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66402efb49b709895f5afb18e9e89a0e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a66402efb49b709895f5afb18e9e89a0e">pfnChangeYaw</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td></tr>
<tr class="separator:a66402efb49b709895f5afb18e9e89a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f24e56a340e98168c21cce9f40ba202"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a0f24e56a340e98168c21cce9f40ba202">pfnChangePitch</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td></tr>
<tr class="separator:a0f24e56a340e98168c21cce9f40ba202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518e79c3711854ab2a64a6a126a9e072"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structedict__t.html">edict_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a518e79c3711854ab2a64a6a126a9e072">pfnFindEntityByString</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEdictStartSearchAfter, const char *pszField, const char *pszValue)</td></tr>
<tr class="separator:a518e79c3711854ab2a64a6a126a9e072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6641de1e58d2ece0b5e1abe2c5afd1f1"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a6641de1e58d2ece0b5e1abe2c5afd1f1">pfnGetEntityIllum</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEnt)</td></tr>
<tr class="separator:a6641de1e58d2ece0b5e1abe2c5afd1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af226c43a9f436e744b5e226aa3d7fb1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structedict__t.html">edict_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#af226c43a9f436e744b5e226aa3d7fb1a">pfnFindEntityInSphere</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEdictStartSearchAfter, const <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin, float rad)</td></tr>
<tr class="separator:af226c43a9f436e744b5e226aa3d7fb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea676484576c8b73e2cb07d0696a9c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structedict__t.html">edict_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a2ea676484576c8b73e2cb07d0696a9c9">pfnFindClientInPVS</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td></tr>
<tr class="separator:a2ea676484576c8b73e2cb07d0696a9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec103b29f86a80950d401b6a2e2e0e3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structedict__t.html">edict_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#aec103b29f86a80950d401b6a2e2e0e3d">pfnEntitiesInPVS</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td></tr>
<tr class="separator:aec103b29f86a80950d401b6a2e2e0e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3f35ab00e1327b4a47bcae7b767ccd"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#add3f35ab00e1327b4a47bcae7b767ccd">pfnMakeVectors</a> )(const <a class="el" href="class_vector.html">Vector</a> &amp;vecVector)</td></tr>
<tr class="separator:add3f35ab00e1327b4a47bcae7b767ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8619cb843ba8290ed6858ef5e0d0730"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#aa8619cb843ba8290ed6858ef5e0d0730">pfnAngleVectors</a> )(const <a class="el" href="class_vector.html">Vector</a> &amp;vecVector, float *forward, float *right, float *up)</td></tr>
<tr class="separator:aa8619cb843ba8290ed6858ef5e0d0730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626c8bc9da07532bf97dde73faf1f0c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structedict__t.html">edict_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a626c8bc9da07532bf97dde73faf1f0c0">pfnCreateEntity</a> )(void)</td></tr>
<tr class="separator:a626c8bc9da07532bf97dde73faf1f0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d85b6dfd785c3485a0c5e8a115ea5c6"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a7d85b6dfd785c3485a0c5e8a115ea5c6">pfnRemoveEntity</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td></tr>
<tr class="separator:a7d85b6dfd785c3485a0c5e8a115ea5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e45a16dcbfabe4b810d414c888412e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structedict__t.html">edict_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a7e45a16dcbfabe4b810d414c888412e7">pfnCreateNamedEntity</a> )(<a class="el" href="const_8h.html#a8b54a01f6c8e1ccdad69c14a181c3d45">string_t</a> iszClassName)</td></tr>
<tr class="separator:a7e45a16dcbfabe4b810d414c888412e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d700b7e89687303023f5a2f066f837"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ad9d700b7e89687303023f5a2f066f837">pfnMakeStatic</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td></tr>
<tr class="separator:ad9d700b7e89687303023f5a2f066f837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbad015f14bfb3defc6e6e394b875f7"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a8bbad015f14bfb3defc6e6e394b875f7">pfnEntIsOnFloor</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td></tr>
<tr class="separator:a8bbad015f14bfb3defc6e6e394b875f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fe8e47e89ac93716d31f8b7f5f43cb"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ae3fe8e47e89ac93716d31f8b7f5f43cb">pfnDropToFloor</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td></tr>
<tr class="separator:ae3fe8e47e89ac93716d31f8b7f5f43cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbb55e6ec08db6ccda8419143722b1b"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a0cbb55e6ec08db6ccda8419143722b1b">pfnWalkMove</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity, float yaw, float dist, int iMode)</td></tr>
<tr class="separator:a0cbb55e6ec08db6ccda8419143722b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bd6475d9a215d2798d48d265b333ab"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a49bd6475d9a215d2798d48d265b333ab">pfnSetOrigin</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity, const <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin)</td></tr>
<tr class="separator:a49bd6475d9a215d2798d48d265b333ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd778189a8b42b85124e20cc2ec6eda"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#aedd778189a8b42b85124e20cc2ec6eda">pfnEmitSound</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity, int channel, const char *pszSample, float volume, float attenuation, int fFlags, int pitch)</td></tr>
<tr class="separator:aedd778189a8b42b85124e20cc2ec6eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c59fdfc860322fdad9570bb65c9430"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ae6c59fdfc860322fdad9570bb65c9430">pfnEmitAmbientSound</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity, const <a class="el" href="class_vector.html">Vector</a> &amp;vecPos, const char *pszSample, float vol, float attenuation, int fFlags, int pitch)</td></tr>
<tr class="separator:ae6c59fdfc860322fdad9570bb65c9430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158d227a8f73eb4b206ed3c882cbc1a7"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a158d227a8f73eb4b206ed3c882cbc1a7">pfnTraceLine</a> )(const <a class="el" href="class_vector.html">Vector</a> &amp;vecStart, const <a class="el" href="class_vector.html">Vector</a> &amp;vecEnd, int fNoMonsters, <a class="el" href="structedict__t.html">edict_t</a> *pentToSkip, <a class="el" href="struct_trace_result.html">TraceResult</a> *ptr)</td></tr>
<tr class="separator:a158d227a8f73eb4b206ed3c882cbc1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b99988b13711ea32d0bf4ddc4ce6c93"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a5b99988b13711ea32d0bf4ddc4ce6c93">pfnTraceToss</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity, <a class="el" href="structedict__t.html">edict_t</a> *pentToIgnore, <a class="el" href="struct_trace_result.html">TraceResult</a> *ptr)</td></tr>
<tr class="separator:a5b99988b13711ea32d0bf4ddc4ce6c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f5326711aa17c8f734288e8f86bd3d"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a04f5326711aa17c8f734288e8f86bd3d">pfnTraceMonsterHull</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity, const <a class="el" href="class_vector.html">Vector</a> &amp;vecStart, const <a class="el" href="class_vector.html">Vector</a> &amp;vecEnd, int fNoMonsters, <a class="el" href="structedict__t.html">edict_t</a> *pentToSkip, <a class="el" href="struct_trace_result.html">TraceResult</a> *ptr)</td></tr>
<tr class="separator:a04f5326711aa17c8f734288e8f86bd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66de34a4fb04fac54187dc24c4eb70ff"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a66de34a4fb04fac54187dc24c4eb70ff">pfnTraceHull</a> )(const <a class="el" href="class_vector.html">Vector</a> &amp;vecStart, const <a class="el" href="class_vector.html">Vector</a> &amp;vecEnd, int fNoMonsters, int hullNumber, <a class="el" href="structedict__t.html">edict_t</a> *pentToSkip, <a class="el" href="struct_trace_result.html">TraceResult</a> *ptr)</td></tr>
<tr class="separator:a66de34a4fb04fac54187dc24c4eb70ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b3bbd95259e5c9da81164b7ad2de00"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a17b3bbd95259e5c9da81164b7ad2de00">pfnTraceModel</a> )(const <a class="el" href="class_vector.html">Vector</a> &amp;vecStart, const <a class="el" href="class_vector.html">Vector</a> &amp;vecEnd, int hullNumber, <a class="el" href="structedict__t.html">edict_t</a> *pEntity, <a class="el" href="struct_trace_result.html">TraceResult</a> *ptr)</td></tr>
<tr class="separator:a17b3bbd95259e5c9da81164b7ad2de00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eed3bc999fd9098fbda7d5e72e42299"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structtexture__t.html">texture_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a4eed3bc999fd9098fbda7d5e72e42299">pfnTraceTexture</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pTextureEntity, const <a class="el" href="class_vector.html">Vector</a> &amp;vecStart, const <a class="el" href="class_vector.html">Vector</a> &amp;vecEnd)</td></tr>
<tr class="separator:a4eed3bc999fd9098fbda7d5e72e42299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfca298232ae79dedc22227d801a32c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#afbfca298232ae79dedc22227d801a32c">pfnTraceSphere</a> )(const <a class="el" href="class_vector.html">Vector</a> &amp;vecStart, const <a class="el" href="class_vector.html">Vector</a> &amp;vecEnd, int fNoMonsters, float radius, <a class="el" href="structedict__t.html">edict_t</a> *pentToSkip, <a class="el" href="struct_trace_result.html">TraceResult</a> *ptr)</td></tr>
<tr class="separator:afbfca298232ae79dedc22227d801a32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b13def219573b1a6f7fa4b69aa6ecd"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ad0b13def219573b1a6f7fa4b69aa6ecd">pfnGetAimVector</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity, float speed, <a class="el" href="class_vector.html">Vector</a> &amp;vecReturn)</td></tr>
<tr class="separator:ad0b13def219573b1a6f7fa4b69aa6ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa96b16b3dd3a87c87aaf0696496473a"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#afa96b16b3dd3a87c87aaf0696496473a">pfnServerCommand</a> )(const char *pszCommand)</td></tr>
<tr class="separator:afa96b16b3dd3a87c87aaf0696496473a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ce4d5597e908cd0718552e3931b5b9"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a75ce4d5597e908cd0718552e3931b5b9">pfnServerExecute</a> )(void)</td></tr>
<tr class="separator:a75ce4d5597e908cd0718552e3931b5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf5925e5429f358d8096f010d3f4223"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a5cf5925e5429f358d8096f010d3f4223">pfnClientCommand</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEdict, const char *pszFormat,...)</td></tr>
<tr class="separator:a5cf5925e5429f358d8096f010d3f4223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca61ed18b6e48d3d1ba91480d4adb046"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#aca61ed18b6e48d3d1ba91480d4adb046">pfnParticleEffect</a> )(const <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin, const <a class="el" href="class_vector.html">Vector</a> &amp;vecDir, float color, float count)</td></tr>
<tr class="separator:aca61ed18b6e48d3d1ba91480d4adb046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d52525919ab5cc661dea7bf1828a2fe"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a2d52525919ab5cc661dea7bf1828a2fe">pfnLightStyle</a> )(int style, const char *val)</td></tr>
<tr class="separator:a2d52525919ab5cc661dea7bf1828a2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9ed5a5722a32dcb9fbded7d33a114b"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#acf9ed5a5722a32dcb9fbded7d33a114b">pfnDecalIndex</a> )(const char *pszName)</td></tr>
<tr class="separator:acf9ed5a5722a32dcb9fbded7d33a114b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d35da21d3db362bd4654bea5dd3ab5e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a1d35da21d3db362bd4654bea5dd3ab5e">pfnPointContents</a> )(const <a class="el" href="class_vector.html">Vector</a> &amp;vecVector)</td></tr>
<tr class="separator:a1d35da21d3db362bd4654bea5dd3ab5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d8e917da3498a3374fc1f961922268"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a66d8e917da3498a3374fc1f961922268">pfnMessageBegin</a> )(int iMsgType, int iMsgID, const float *pOrigin, <a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td></tr>
<tr class="separator:a66d8e917da3498a3374fc1f961922268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64a1e947dab6f8a5e46c450bbbbe679"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ad64a1e947dab6f8a5e46c450bbbbe679">pfnMessageEnd</a> )(void)</td></tr>
<tr class="separator:ad64a1e947dab6f8a5e46c450bbbbe679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd9113be2930ca234a5655f2766f888"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#aedd9113be2930ca234a5655f2766f888">pfnWriteByte</a> )(int iValue)</td></tr>
<tr class="separator:aedd9113be2930ca234a5655f2766f888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ece4cfb1d87e6e766a2352073c4ea3"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ab6ece4cfb1d87e6e766a2352073c4ea3">pfnWriteChar</a> )(int iValue)</td></tr>
<tr class="separator:ab6ece4cfb1d87e6e766a2352073c4ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ee0f34c619b710e1099f09e8bb20ec"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ab2ee0f34c619b710e1099f09e8bb20ec">pfnWriteShort</a> )(int iValue)</td></tr>
<tr class="separator:ab2ee0f34c619b710e1099f09e8bb20ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3e03347d50d3aa205115dad24f7989"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#add3e03347d50d3aa205115dad24f7989">pfnWriteLong</a> )(int iValue)</td></tr>
<tr class="separator:add3e03347d50d3aa205115dad24f7989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d327e34a3d381636b1ad06b0b23afde"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a1d327e34a3d381636b1ad06b0b23afde">pfnWriteAngle</a> )(float flValue)</td></tr>
<tr class="separator:a1d327e34a3d381636b1ad06b0b23afde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017c7ace8a8e1828faa347698fab2da8"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a017c7ace8a8e1828faa347698fab2da8">pfnWriteCoord</a> )(float flValue)</td></tr>
<tr class="separator:a017c7ace8a8e1828faa347698fab2da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf04813261332735f1b8a7e872038308"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#acf04813261332735f1b8a7e872038308">pfnWriteString</a> )(const char *pszString)</td></tr>
<tr class="separator:acf04813261332735f1b8a7e872038308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07d049d353343287de93159095b5456"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#af07d049d353343287de93159095b5456">pfnWriteEntity</a> )(int iValue)</td></tr>
<tr class="separator:af07d049d353343287de93159095b5456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9863bd16e65b684325e8e1c6c9b1ddf"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ac9863bd16e65b684325e8e1c6c9b1ddf">pfnCVarRegister</a> )(<a class="el" href="structcvar__t.html">cvar_t</a> *pCvar)</td></tr>
<tr class="separator:ac9863bd16e65b684325e8e1c6c9b1ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d9959aa10cab0018c2e83e94470de4"><td class="memItemLeft" align="right" valign="top">float(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a63d9959aa10cab0018c2e83e94470de4">pfnCVarGetFloat</a> )(const char *pszVarName)</td></tr>
<tr class="separator:a63d9959aa10cab0018c2e83e94470de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920afe54710bfd77200047734e887c2c"><td class="memItemLeft" align="right" valign="top">const char *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a920afe54710bfd77200047734e887c2c">pfnCVarGetString</a> )(const char *pszVarName)</td></tr>
<tr class="separator:a920afe54710bfd77200047734e887c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddd3d6f190c77e2e9035369ec7eb792"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#aaddd3d6f190c77e2e9035369ec7eb792">pfnCVarSetFloat</a> )(const char *pszVarName, float flValue)</td></tr>
<tr class="separator:aaddd3d6f190c77e2e9035369ec7eb792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6e1a18e2dc1195d7614e0e2d34ec0d"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a2e6e1a18e2dc1195d7614e0e2d34ec0d">pfnCVarSetString</a> )(const char *pszVarName, const char *pszValue)</td></tr>
<tr class="separator:a2e6e1a18e2dc1195d7614e0e2d34ec0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa871936068901803df9aa03e6b5c5ea3"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#aa871936068901803df9aa03e6b5c5ea3">pfnAlertMessage</a> )(<a class="el" href="const_8h.html#adf2815a4b3300d23505e7427c27da346">ALERT_TYPE</a> aType, const char *pszFormat,...)</td></tr>
<tr class="separator:aa871936068901803df9aa03e6b5c5ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e067f347fbd5fcf5a09c167ec77ac13"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a2e067f347fbd5fcf5a09c167ec77ac13">pfnEngineFprintf</a> )(void *pFile, const char *pszFormat,...)</td></tr>
<tr class="separator:a2e067f347fbd5fcf5a09c167ec77ac13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4312ea356ecec077fc57c63c4acc8dc7"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a4312ea356ecec077fc57c63c4acc8dc7">pfnPvAllocEntPrivateData</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEdict, <a class="el" href="steamtypes_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> cb)</td></tr>
<tr class="separator:a4312ea356ecec077fc57c63c4acc8dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c32c25a6ba537716efaae2f31e2221c"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a2c32c25a6ba537716efaae2f31e2221c">pfnPvEntPrivateData</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td></tr>
<tr class="separator:a2c32c25a6ba537716efaae2f31e2221c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be10d8ec96b158c0adaa8235dcb9d99"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a0be10d8ec96b158c0adaa8235dcb9d99">pfnFreeEntPrivateData</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td></tr>
<tr class="separator:a0be10d8ec96b158c0adaa8235dcb9d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c4739152b4f8f7b0a84717deb48f0b"><td class="memItemLeft" align="right" valign="top">const char *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a05c4739152b4f8f7b0a84717deb48f0b">pfnSzFromIndex</a> )(<a class="el" href="const_8h.html#a8b54a01f6c8e1ccdad69c14a181c3d45">string_t</a> iString)</td></tr>
<tr class="separator:a05c4739152b4f8f7b0a84717deb48f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ca58c3e24d6a375cfe09146cb5a36f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="const_8h.html#a8b54a01f6c8e1ccdad69c14a181c3d45">string_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a23ca58c3e24d6a375cfe09146cb5a36f">pfnAllocString</a> )(const char *pszValue)</td></tr>
<tr class="separator:a23ca58c3e24d6a375cfe09146cb5a36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1408ef071c4c2479f331e5f0744d5fac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structentvars__t.html">entvars_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a1408ef071c4c2479f331e5f0744d5fac">pfnGetVarsOfEnt</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td></tr>
<tr class="separator:a1408ef071c4c2479f331e5f0744d5fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab261f04510bce272412ff7d1cd4af7d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structedict__t.html">edict_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ab261f04510bce272412ff7d1cd4af7d7">pfnPEntityOfEntOffset</a> )(<a class="el" href="eiface_8h.html#a27688f71f76eaf06690fc420a6666076">EOFFSET</a> iEntOffset)</td></tr>
<tr class="separator:ab261f04510bce272412ff7d1cd4af7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2dc7591944b388641e19f112b48c94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="eiface_8h.html#a27688f71f76eaf06690fc420a6666076">EOFFSET</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a8c2dc7591944b388641e19f112b48c94">pfnEntOffsetOfPEntity</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td></tr>
<tr class="separator:a8c2dc7591944b388641e19f112b48c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a127082954a30e2b7d046fbfb9d346c"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a9a127082954a30e2b7d046fbfb9d346c">pfnIndexOfEdict</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td></tr>
<tr class="separator:a9a127082954a30e2b7d046fbfb9d346c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70975629f061f5d6a9e022ea9585fcae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structedict__t.html">edict_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a70975629f061f5d6a9e022ea9585fcae">pfnPEntityOfEntIndex</a> )(int iEntIndex)</td></tr>
<tr class="separator:a70975629f061f5d6a9e022ea9585fcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb58e4431428d1672b15bdae45be519"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structedict__t.html">edict_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a8eb58e4431428d1672b15bdae45be519">pfnFindEntityByVars</a> )(<a class="el" href="structentvars__t.html">entvars_t</a> *pVars)</td></tr>
<tr class="separator:a8eb58e4431428d1672b15bdae45be519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd5612ce8d95a534d362165416369dc"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a8cd5612ce8d95a534d362165416369dc">pfnGetModelPtr</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td></tr>
<tr class="separator:a8cd5612ce8d95a534d362165416369dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6133f846451400913a551a7e8d02eb"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a5e6133f846451400913a551a7e8d02eb">pfnRegUserMsg</a> )(const char *pszName, int iSize)</td></tr>
<tr class="separator:a5e6133f846451400913a551a7e8d02eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95a6451dc6edbcb6505702ff39cd5b0"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#af95a6451dc6edbcb6505702ff39cd5b0">pfnAnimationAutomove</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pEdict, float flTime)</td></tr>
<tr class="separator:af95a6451dc6edbcb6505702ff39cd5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbb21247d9f726c5b1fea8236afb07e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a4fbb21247d9f726c5b1fea8236afb07e">pfnGetBonePosition</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pEdict, int iBone, <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin, <a class="el" href="class_vector.html">Vector</a> &amp;vecAngles)</td></tr>
<tr class="separator:a4fbb21247d9f726c5b1fea8236afb07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b5187ad35fdd2e09caa486f1d287c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="const_8h.html#a615188600515ea51267daa7198237405">func_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a09b5187ad35fdd2e09caa486f1d287c1">pfnFunctionFromName</a> )(const char *pszName)</td></tr>
<tr class="separator:a09b5187ad35fdd2e09caa486f1d287c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c92dc560d09f883a540891f68fe82f3"><td class="memItemLeft" align="right" valign="top">const char *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a0c92dc560d09f883a540891f68fe82f3">pfnNameForFunction</a> )(<a class="el" href="const_8h.html#a615188600515ea51267daa7198237405">func_t</a> function)</td></tr>
<tr class="separator:a0c92dc560d09f883a540891f68fe82f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae012771231ab7346f1129b5a6a43b5d1"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ae012771231ab7346f1129b5a6a43b5d1">pfnClientPrintf</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEdict, <a class="el" href="eiface_8h.html#a0d9a05d88ef681f9a1e7d362f6f20ac1">PRINT_TYPE</a> pType, const char *pszMessage)</td></tr>
<tr class="separator:ae012771231ab7346f1129b5a6a43b5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f676ae9a0ebb14495abaa46ed976666"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a6f676ae9a0ebb14495abaa46ed976666">pfnServerPrint</a> )(const char *szMsg)</td></tr>
<tr class="separator:a6f676ae9a0ebb14495abaa46ed976666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd2ae76c7bda444b69be84818d3feaf"><td class="memItemLeft" align="right" valign="top">const char *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a3dd2ae76c7bda444b69be84818d3feaf">pfnCmd_Args</a> )(void)</td></tr>
<tr class="separator:a3dd2ae76c7bda444b69be84818d3feaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c467675fbc85972742de722f5ce875"><td class="memItemLeft" align="right" valign="top">const char *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a20c467675fbc85972742de722f5ce875">pfnCmd_Argv</a> )(int argc)</td></tr>
<tr class="separator:a20c467675fbc85972742de722f5ce875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d18d17c26875c41a929f9e2ad6b237e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a7d18d17c26875c41a929f9e2ad6b237e">pfnCmd_Argc</a> )(void)</td></tr>
<tr class="separator:a7d18d17c26875c41a929f9e2ad6b237e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdab964f9a6c55bac79c9ba82272f0f"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a9fdab964f9a6c55bac79c9ba82272f0f">pfnGetAttachment</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pEdict, int iAttachment, <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin, <a class="el" href="class_vector.html">Vector</a> &amp;vecAngles)</td></tr>
<tr class="separator:a9fdab964f9a6c55bac79c9ba82272f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51843cef3802474c87bb9c9ae48358a5"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a51843cef3802474c87bb9c9ae48358a5">pfnCRC32_Init</a> )(<a class="el" href="crc_8h.html#ac7476db75bdc35bc021d17ec36e17cbd">CRC32_t</a> *pulCRC)</td></tr>
<tr class="separator:a51843cef3802474c87bb9c9ae48358a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4f27f6ccca5c1043a2d2fd2e445fe1"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a8f4f27f6ccca5c1043a2d2fd2e445fe1">pfnCRC32_ProcessBuffer</a> )(<a class="el" href="crc_8h.html#ac7476db75bdc35bc021d17ec36e17cbd">CRC32_t</a> *pulCRC, void *pBuffer, int len)</td></tr>
<tr class="separator:a8f4f27f6ccca5c1043a2d2fd2e445fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad265bc2315c1e8a3822f0dacbc7223e5"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ad265bc2315c1e8a3822f0dacbc7223e5">pfnCRC32_ProcessByte</a> )(<a class="el" href="crc_8h.html#ac7476db75bdc35bc021d17ec36e17cbd">CRC32_t</a> *pulCRC, unsigned char ch)</td></tr>
<tr class="separator:ad265bc2315c1e8a3822f0dacbc7223e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9631abf18d7802f9e071d165e2985d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="crc_8h.html#ac7476db75bdc35bc021d17ec36e17cbd">CRC32_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a7f9631abf18d7802f9e071d165e2985d">pfnCRC32_Final</a> )(<a class="el" href="crc_8h.html#ac7476db75bdc35bc021d17ec36e17cbd">CRC32_t</a> pulCRC)</td></tr>
<tr class="separator:a7f9631abf18d7802f9e071d165e2985d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6197d3002442d15e8517d16c62b69d26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="steamtypes_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a6197d3002442d15e8517d16c62b69d26">pfnRandomLong</a> )(<a class="el" href="steamtypes_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> lLow, <a class="el" href="steamtypes_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> lHigh)</td></tr>
<tr class="separator:a6197d3002442d15e8517d16c62b69d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5611f60018b3584551c891941c6f7d"><td class="memItemLeft" align="right" valign="top">float(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a5a5611f60018b3584551c891941c6f7d">pfnRandomFloat</a> )(float flLow, float flHigh)</td></tr>
<tr class="separator:a5a5611f60018b3584551c891941c6f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ace4a58a536eec885aef476e287c2f1"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a3ace4a58a536eec885aef476e287c2f1">pfnSetView</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pClient, const <a class="el" href="structedict__t.html">edict_t</a> *pViewent)</td></tr>
<tr class="separator:a3ace4a58a536eec885aef476e287c2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0555413d378e2c74c01eb2a3fa49d12"><td class="memItemLeft" align="right" valign="top">float(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ab0555413d378e2c74c01eb2a3fa49d12">pfnTime</a> )(void)</td></tr>
<tr class="separator:ab0555413d378e2c74c01eb2a3fa49d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375c321d3ea645e20550be3f61b1fece"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a375c321d3ea645e20550be3f61b1fece">pfnCrosshairAngle</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pClient, float pitch, float yaw)</td></tr>
<tr class="separator:a375c321d3ea645e20550be3f61b1fece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01cbba541725146d671768046fa162a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="const_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a01cbba541725146d671768046fa162a2">pfnLoadFileForMe</a> )(const char *pszFilename, int *pLength)</td></tr>
<tr class="separator:a01cbba541725146d671768046fa162a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658654ce21a9eb55055a8b4ab036fc94"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a658654ce21a9eb55055a8b4ab036fc94">pfnFreeFile</a> )(void *pBuffer)</td></tr>
<tr class="separator:a658654ce21a9eb55055a8b4ab036fc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ded806c92f451fe617413b9c2e91fe9"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a0ded806c92f451fe617413b9c2e91fe9">pfnEndSection</a> )(const char *pszSectionName)</td></tr>
<tr class="separator:a0ded806c92f451fe617413b9c2e91fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4477b95722bcf422c2ed03a9dac221c6"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a4477b95722bcf422c2ed03a9dac221c6">pfnCompareFileTime</a> )(const char *pszFilename1, const char *pszFilename2, int *piCompare)</td></tr>
<tr class="separator:a4477b95722bcf422c2ed03a9dac221c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7128bdb28188b8a633bc33d55efa63e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ac7128bdb28188b8a633bc33d55efa63e">pfnGetGameDir</a> )(char *pszGetGameDir)</td></tr>
<tr class="separator:ac7128bdb28188b8a633bc33d55efa63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac321f32b3540b5d7519cfb711eaaa827"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ac321f32b3540b5d7519cfb711eaaa827">pfnCvar_RegisterVariable</a> )(<a class="el" href="structcvar__t.html">cvar_t</a> *variable)</td></tr>
<tr class="separator:ac321f32b3540b5d7519cfb711eaaa827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34be044631214fe6cb1a99b43d498312"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a34be044631214fe6cb1a99b43d498312">pfnFadeClientVolume</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pEdict, int fadePercent, int fadeOutSeconds, int holdTime, int fadeInSeconds)</td></tr>
<tr class="separator:a34be044631214fe6cb1a99b43d498312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39e1c1a497bdd564ad25659f6efd342"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ac39e1c1a497bdd564ad25659f6efd342">pfnSetClientMaxspeed</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pEdict, float flNewMaxspeed)</td></tr>
<tr class="separator:ac39e1c1a497bdd564ad25659f6efd342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72020defed33477c4d6f1fc3aeb962b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structedict__t.html">edict_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a72020defed33477c4d6f1fc3aeb962b7">pfnCreateFakeClient</a> )(const char *pszNetName)</td></tr>
<tr class="separator:a72020defed33477c4d6f1fc3aeb962b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab224bca3f733f19741dbb69f96e15ff4"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ab224bca3f733f19741dbb69f96e15ff4">pfnRunPlayerMove</a> )(<a class="el" href="structedict__t.html">edict_t</a> *fakeclient, const <a class="el" href="class_vector.html">Vector</a> &amp;vecViewangles, float forwardmove, float sidemove, float upmove, unsigned short buttons, <a class="el" href="const_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> impulse, <a class="el" href="const_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> msec)</td></tr>
<tr class="separator:ab224bca3f733f19741dbb69f96e15ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b8b44c95704c1916ba8f2aad69ea9b"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ac7b8b44c95704c1916ba8f2aad69ea9b">pfnNumberOfEntities</a> )(void)</td></tr>
<tr class="separator:ac7b8b44c95704c1916ba8f2aad69ea9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0827c1c1fc1858e0fd8f0fad6a9d9503"><td class="memItemLeft" align="right" valign="top">char *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a0827c1c1fc1858e0fd8f0fad6a9d9503">pfnGetInfoKeyBuffer</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pClient)</td></tr>
<tr class="separator:a0827c1c1fc1858e0fd8f0fad6a9d9503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c1b7394ee2901223b41626da260396"><td class="memItemLeft" align="right" valign="top">char *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#aa1c1b7394ee2901223b41626da260396">pfnInfoKeyValue</a> )(const char *pszInfoBuffer, const char *pszKey)</td></tr>
<tr class="separator:aa1c1b7394ee2901223b41626da260396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7adb348f0adae1e603ad425dca0abc51"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a7adb348f0adae1e603ad425dca0abc51">pfnSetKeyValue</a> )(char *pszInfoBuffer, const char *pszKey, char *pszValue)</td></tr>
<tr class="separator:a7adb348f0adae1e603ad425dca0abc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a280d508e0b9f0419cdeab3b492cc72"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a2a280d508e0b9f0419cdeab3b492cc72">pfnSetClientKeyValue</a> )(int clientIndex, char *pszInfoBuffer, const char *pszKey, char *pszValue)</td></tr>
<tr class="separator:a2a280d508e0b9f0419cdeab3b492cc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7fd1de9002f9a5830a8559cd840b3a"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a4d7fd1de9002f9a5830a8559cd840b3a">pfnIsMapValid</a> )(const char *pszFilename)</td></tr>
<tr class="separator:a4d7fd1de9002f9a5830a8559cd840b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9007c8c9559d721f9431448c52ae86"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a2b9007c8c9559d721f9431448c52ae86">pfnStaticDecal</a> )(const <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin, int decalIndex, int entityIndex, int modelIndex)</td></tr>
<tr class="separator:a2b9007c8c9559d721f9431448c52ae86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c27718fb8289e64a47aff6e32153675"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a6c27718fb8289e64a47aff6e32153675">pfnPrecacheGeneric</a> )(const char *pszFilename)</td></tr>
<tr class="separator:a6c27718fb8289e64a47aff6e32153675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16cfc2315fff39a15270222457f2270"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#aa16cfc2315fff39a15270222457f2270">pfnGetPlayerUserId</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td></tr>
<tr class="separator:aa16cfc2315fff39a15270222457f2270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd566ab4854caa69556a2c61ac0bedd"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a8fd566ab4854caa69556a2c61ac0bedd">pfnBuildSoundMsg</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity, int channel, const char *pszSample, float volume, float attenuation, int fFlags, int pitch, int iMsgType, int iMsgID, const <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin, <a class="el" href="structedict__t.html">edict_t</a> *ed)</td></tr>
<tr class="separator:a8fd566ab4854caa69556a2c61ac0bedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addad0e7fa3fb5033cd6e20386015f3c4"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#addad0e7fa3fb5033cd6e20386015f3c4">pfnIsDedicatedServer</a> )(void)</td></tr>
<tr class="separator:addad0e7fa3fb5033cd6e20386015f3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d383e4a3ef5c0c33b36dbc72688d09f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcvar__t.html">cvar_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a4d383e4a3ef5c0c33b36dbc72688d09f">pfnCVarGetPointer</a> )(const char *pszVarName)</td></tr>
<tr class="separator:a4d383e4a3ef5c0c33b36dbc72688d09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b287aecb46c9e710444e2350136cb7d"><td class="memItemLeft" align="right" valign="top">unsigned int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a3b287aecb46c9e710444e2350136cb7d">pfnGetPlayerWONId</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td></tr>
<tr class="separator:a3b287aecb46c9e710444e2350136cb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4481fbd6a6fc244af2392cc41c085d"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a4e4481fbd6a6fc244af2392cc41c085d">pfnInfo_RemoveKey</a> )(char *pszInfoBuffer, const char *pszKey)</td></tr>
<tr class="separator:a4e4481fbd6a6fc244af2392cc41c085d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafa492c5508c9038ef91947cc4f4c41"><td class="memItemLeft" align="right" valign="top">const char *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#afafa492c5508c9038ef91947cc4f4c41">pfnGetPhysicsKeyValue</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pClient, const char *pszKey)</td></tr>
<tr class="separator:afafa492c5508c9038ef91947cc4f4c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3864b2195d2446254aaac2fadf19b90a"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a3864b2195d2446254aaac2fadf19b90a">pfnSetPhysicsKeyValue</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pClient, const char *pszKey, const char *pszValue)</td></tr>
<tr class="separator:a3864b2195d2446254aaac2fadf19b90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475d46b21ace17d7f001ab5f7f1c590c"><td class="memItemLeft" align="right" valign="top">const char *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a475d46b21ace17d7f001ab5f7f1c590c">pfnGetPhysicsInfoString</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pClient)</td></tr>
<tr class="separator:a475d46b21ace17d7f001ab5f7f1c590c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf40676e8f8c4ff14380f94b67da489a"><td class="memItemLeft" align="right" valign="top">unsigned short(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#adf40676e8f8c4ff14380f94b67da489a">pfnPrecacheEvent</a> )(int type, const char *pszEventName)</td></tr>
<tr class="separator:adf40676e8f8c4ff14380f94b67da489a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae4216d68b6d459de995a7272ffa578"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a2ae4216d68b6d459de995a7272ffa578">pfnPlaybackEvent</a> )(int flags, const <a class="el" href="structedict__t.html">edict_t</a> *pInvoker, unsigned short eventindex, float delay, const <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin, const <a class="el" href="class_vector.html">Vector</a> &amp;vecAngles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2)</td></tr>
<tr class="separator:a2ae4216d68b6d459de995a7272ffa578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063a4c7d3db0cd428664e19dade1bd61"><td class="memItemLeft" align="right" valign="top">unsigned char *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a063a4c7d3db0cd428664e19dade1bd61">pfnSetFatPVS</a> )(const <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin)</td></tr>
<tr class="separator:a063a4c7d3db0cd428664e19dade1bd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b30c3ab84034fa163f74cedf91da79"><td class="memItemLeft" align="right" valign="top">unsigned char *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#af2b30c3ab84034fa163f74cedf91da79">pfnSetFatPAS</a> )(const <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin)</td></tr>
<tr class="separator:af2b30c3ab84034fa163f74cedf91da79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257d7e579dbb39a5304203020bf2d2d9"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a257d7e579dbb39a5304203020bf2d2d9">pfnCheckVisibility</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pEntity, unsigned char *pVisibleSet)</td></tr>
<tr class="separator:a257d7e579dbb39a5304203020bf2d2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec820d28a9a2bd63f07e1b5fb806608"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a9ec820d28a9a2bd63f07e1b5fb806608">pfnDeltaSetField</a> )(delta_t *pFields, const char *pszFieldName)</td></tr>
<tr class="separator:a9ec820d28a9a2bd63f07e1b5fb806608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da5d7c31e2dd3d4e39712d4eb10e62f"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a0da5d7c31e2dd3d4e39712d4eb10e62f">pfnDeltaUnsetField</a> )(delta_t *pFields, const char *pszFieldName)</td></tr>
<tr class="separator:a0da5d7c31e2dd3d4e39712d4eb10e62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14cd05df97eeca2679979a329473cc6"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ac14cd05df97eeca2679979a329473cc6">pfnDeltaAddEncoder</a> )(const char *const pszName, void(*conditionalencode)(delta_t *pFields, const unsigned char *from, const unsigned char *to))</td></tr>
<tr class="separator:ac14cd05df97eeca2679979a329473cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54696e00893179cbc1989eacfacacaf2"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a54696e00893179cbc1989eacfacacaf2">pfnGetCurrentPlayer</a> )(void)</td></tr>
<tr class="separator:a54696e00893179cbc1989eacfacacaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abddecbf00de45dac3f7339d82661fc"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a4abddecbf00de45dac3f7339d82661fc">pfnCanSkipPlayer</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pPlayer)</td></tr>
<tr class="separator:a4abddecbf00de45dac3f7339d82661fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2f77756e10abf47e60216f7d6781e0"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a3b2f77756e10abf47e60216f7d6781e0">pfnDeltaFindField</a> )(delta_t *pFields, const char *pszFieldName)</td></tr>
<tr class="separator:a3b2f77756e10abf47e60216f7d6781e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b818ddc23fe08913b88adf010500253"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a7b818ddc23fe08913b88adf010500253">pfnDeltaSetFieldByIndex</a> )(delta_t *pFields, int fieldNumber)</td></tr>
<tr class="separator:a7b818ddc23fe08913b88adf010500253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c9c041465c1b0c3802cec12fc45d77"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ad7c9c041465c1b0c3802cec12fc45d77">pfnDeltaUnsetFieldByIndex</a> )(delta_t *pFields, int fieldNumber)</td></tr>
<tr class="separator:ad7c9c041465c1b0c3802cec12fc45d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63bfbce305e927679b48748f4214133"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ae63bfbce305e927679b48748f4214133">pfnSetGroupMask</a> )(int mask, int op)</td></tr>
<tr class="separator:ae63bfbce305e927679b48748f4214133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da4235cde80c7b7f810d425aa126d26"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a1da4235cde80c7b7f810d425aa126d26">pfnCreateInstancedBaseline</a> )(<a class="el" href="const_8h.html#a8b54a01f6c8e1ccdad69c14a181c3d45">string_t</a> iszClassName, <a class="el" href="structentity__state__t.html">entity_state_t</a> *baseline)</td></tr>
<tr class="separator:a1da4235cde80c7b7f810d425aa126d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbbb39a111d952c8f2cfb10e6990e19"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a2fbbb39a111d952c8f2cfb10e6990e19">pfnCvar_DirectSet</a> )(<a class="el" href="structcvar__t.html">cvar_t</a> *pCvar, const char *pszValue)</td></tr>
<tr class="separator:a2fbbb39a111d952c8f2cfb10e6990e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5012e7fd0074a69b9153bed00d58b714"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a5012e7fd0074a69b9153bed00d58b714">pfnForceUnmodified</a> )(<a class="el" href="eiface_8h.html#aa333c14e3f31249bd181abd7b2d656d2">FORCE_TYPE</a> type, const float *mins, const float *maxs, const char *pszFilename)</td></tr>
<tr class="separator:a5012e7fd0074a69b9153bed00d58b714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a86bb2a43d77656f171250641ce61c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a32a86bb2a43d77656f171250641ce61c">pfnGetPlayerStats</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pClient, int *piPing, int *piPacket_loss)</td></tr>
<tr class="separator:a32a86bb2a43d77656f171250641ce61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a312e88bbe7ad469fb131f102328c60"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a5a312e88bbe7ad469fb131f102328c60">pfnAddServerCommand</a> )(const char *pszCommandName, void(*function)(void))</td></tr>
<tr class="separator:a5a312e88bbe7ad469fb131f102328c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974aa27586a73844436c62dbd62d989b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cmdlib_8h.html#a110846a9664bbd925f955266e60e9136">qboolean</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a974aa27586a73844436c62dbd62d989b">pfnVoice_GetClientListening</a> )(int iReceiver, int iSender)</td></tr>
<tr class="separator:a974aa27586a73844436c62dbd62d989b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184b9c345e6450943518f25396626508"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cmdlib_8h.html#a110846a9664bbd925f955266e60e9136">qboolean</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a184b9c345e6450943518f25396626508">pfnVoice_SetClientListening</a> )(int iReceiver, int iSender, <a class="el" href="cmdlib_8h.html#a110846a9664bbd925f955266e60e9136">qboolean</a> bListen)</td></tr>
<tr class="separator:a184b9c345e6450943518f25396626508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bc51e64c4368e9513342a5dc41cdfa"><td class="memItemLeft" align="right" valign="top">const char *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a74bc51e64c4368e9513342a5dc41cdfa">pfnGetPlayerAuthId</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td></tr>
<tr class="separator:a74bc51e64c4368e9513342a5dc41cdfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9145a911151d80bebfa1bd834840aa27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsequence_entry__t.html">sequenceEntry_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a9145a911151d80bebfa1bd834840aa27">pfnSequenceGet</a> )(const char *pszFileName, const char *pszEntryName)</td></tr>
<tr class="separator:a9145a911151d80bebfa1bd834840aa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79628bb9d9b9840f6ec6192429e2f81c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsentence_entry__t.html">sentenceEntry_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a79628bb9d9b9840f6ec6192429e2f81c">pfnSequencePickSentence</a> )(const char *pszGroupName, int pickMethod, int *piPicked)</td></tr>
<tr class="separator:a79628bb9d9b9840f6ec6192429e2f81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930aca9d0b58159674cdbb4c24ac4e35"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a930aca9d0b58159674cdbb4c24ac4e35">pfnGetFileSize</a> )(const char *pszFileName)</td></tr>
<tr class="separator:a930aca9d0b58159674cdbb4c24ac4e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c594b7141a80a57823f3e60d951895"><td class="memItemLeft" align="right" valign="top">unsigned int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ab7c594b7141a80a57823f3e60d951895">pfnGetApproxWavePlayLen</a> )(const char *pszFilePath)</td></tr>
<tr class="separator:ab7c594b7141a80a57823f3e60d951895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ebe49940989605ba0d962d7cd9a522"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ab5ebe49940989605ba0d962d7cd9a522">pfnIsCareerMatch</a> )(void)</td></tr>
<tr class="separator:ab5ebe49940989605ba0d962d7cd9a522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4252f3735c548b622bf7c0aabf596f3"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ac4252f3735c548b622bf7c0aabf596f3">pfnGetLocalizedStringLength</a> )(const char *pszLabel)</td></tr>
<tr class="separator:ac4252f3735c548b622bf7c0aabf596f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1b1fc5c3f47c9286f844cb4c549470"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a5f1b1fc5c3f47c9286f844cb4c549470">pfnRegisterTutorMessageShown</a> )(int iMessageID)</td></tr>
<tr class="separator:a5f1b1fc5c3f47c9286f844cb4c549470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c46053284d0177ab72e77fed96be6c7"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a3c46053284d0177ab72e77fed96be6c7">pfnGetTimesTutorMessageShown</a> )(int iMessageID)</td></tr>
<tr class="separator:a3c46053284d0177ab72e77fed96be6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1fccd1c86a2136c61387f4855b86a8"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a7b1fccd1c86a2136c61387f4855b86a8">ProcessTutorMessageDecayBuffer</a> )(int *pBuffer, int bufferLength)</td></tr>
<tr class="separator:a7b1fccd1c86a2136c61387f4855b86a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49bf982447047eef6639b74c1de7ae8"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#ae49bf982447047eef6639b74c1de7ae8">ConstructTutorMessageDecayBuffer</a> )(int *pBuffer, int bufferLength)</td></tr>
<tr class="separator:ae49bf982447047eef6639b74c1de7ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14067cd5bf89168e73925c4141a738f6"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a14067cd5bf89168e73925c4141a738f6">ResetTutorMessageDecayData</a> )(void)</td></tr>
<tr class="separator:a14067cd5bf89168e73925c4141a738f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9caf89b5940e20594979af1f1db64b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a2f9caf89b5940e20594979af1f1db64b">pfnQueryClientCvarValue</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pPlayer, const char *pszCvarName)</td></tr>
<tr class="separator:a2f9caf89b5940e20594979af1f1db64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820fbde7433df615253467d6168ea3c6"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a820fbde7433df615253467d6168ea3c6">pfnQueryClientCvarValue2</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pPlayer, const char *pszCvarName, int requestID)</td></tr>
<tr class="separator:a820fbde7433df615253467d6168ea3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fed4a596079b9e4b140b4121b18c9ae"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenginefuncs__t.html#a7fed4a596079b9e4b140b4121b18c9ae">pfnCheckParm</a> )(const char *pszCmdLineToken, char **ppNext)</td></tr>
<tr class="separator:a7fed4a596079b9e4b140b4121b18c9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Engine hands this to DLLs for functionality callbacks ONLY ADD NEW FUNCTIONS TO THE END OF THIS STRUCT. INTERFACE VERSION IS FROZEN AT 138 (actually 140) </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae49bf982447047eef6639b74c1de7ae8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::ConstructTutorMessageDecayBuffer) (int *pBuffer, int bufferLength)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs the tutor message decay buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuffer</td><td>Buffer. </td></tr>
    <tr><td class="paramname">bufferLength</td><td>Size of the buffer, in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a312e88bbe7ad469fb131f102328c60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnAddServerCommand) (const char *pszCommandName, void(*function)(void))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a server command. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszCommandName</td><td>Name of the command to add. This string must live for the rest of the server's lifetime. </td></tr>
    <tr><td class="paramname">function</td><td>Function to invoke when the command is received. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa871936068901803df9aa03e6b5c5ea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnAlertMessage) (<a class="el" href="const_8h.html#adf2815a4b3300d23505e7427c27da346">ALERT_TYPE</a> aType, const char *pszFormat,...)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outputs a message to the server console. If aType is at_logged and this is a multiplayer game, logs the message to the log file. Otherwise, if the developer cvar is not 0, outputs the message to the console. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aType</td><td>Type of message. </td></tr>
    <tr><td class="paramname">pszFormat</td><td>Format string. </td></tr>
    <tr><td class="paramname">...</td><td>Format arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23ca58c3e24d6a375cfe09146cb5a36f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="const_8h.html#a8b54a01f6c8e1ccdad69c14a181c3d45">string_t</a>(* enginefuncs_t::pfnAllocString) (const char *pszValue)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a string in the string pool. This will allocate memory from the hunk. If the hunk runs out of memory, will trigger sys error. Each call allocates new memory. No actual pooling of strings occurs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszValue</td><td><a class="el" href="namespace_string.html">String</a> to allocate. </td></tr>
    <tr><td class="paramname">Index</td><td>assigned to the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8619cb843ba8290ed6858ef5e0d0730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnAngleVectors) (const <a class="el" href="class_vector.html">Vector</a> &amp;vecVector, float *forward, float *right, float *up)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make direction vectors from angles. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecVector</td><td>Angles to convert to direction vectors. </td></tr>
    <tr><td class="paramname">forward</td><td>Stores the forward direction vector. </td></tr>
    <tr><td class="paramname">right</td><td>Stores the right direction vector. </td></tr>
    <tr><td class="paramname">up</td><td>Stores the up direction vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af95a6451dc6edbcb6505702ff39cd5b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnAnimationAutomove) (const <a class="el" href="structedict__t.html">edict_t</a> *pEdict, float flTime)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does nothing. </p>

</div>
</div>
<a class="anchor" id="a8fd566ab4854caa69556a2c61ac0bedd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnBuildSoundMsg) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity, int channel, const char *pszSample, float volume, float attenuation, int fFlags, int pitch, int iMsgType, int iMsgID, const <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin, <a class="el" href="structedict__t.html">edict_t</a> *ed)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds a sound message to send to a client. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> that is playing the sound. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel to play the sound on. </td></tr>
    <tr><td class="paramname">pszSample</td><td>Sound to play. </td></tr>
    <tr><td class="paramname">volume</td><td>Volume of the sound. Must be in the range [ 0, 1 ]. </td></tr>
    <tr><td class="paramname">attenuation</td><td>Attenuation. </td></tr>
    <tr><td class="paramname">fFlags</td><td>Sound flags. </td></tr>
    <tr><td class="paramname">pitch</td><td>Pitch. Must be in the range [ 0, 255 ]. </td></tr>
    <tr><td class="paramname">iMsgType</td><td>Message type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="const_8h.html#a81e963d13a00ec761f3cd16507fe0cf3">NetMessageType</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iMsgID</td><td>Message ID. </td></tr>
    <tr><td class="paramname">vecOrigin</td><td>Origin in the world to use for PAS and PVS messages. </td></tr>
    <tr><td class="paramname">ed</td><td>Client to send the message to for message types that target one client. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4abddecbf00de45dac3f7339d82661fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnCanSkipPlayer) (const <a class="el" href="structedict__t.html">edict_t</a> *pPlayer)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the given client has cl_lw (weapon prediction) enabled. </dd></dl>

</div>
</div>
<a class="anchor" id="a617f7beb26833c0fb4968f351fc8c183"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnChangeLevel) (const char *pszLevelName, const char *pszLandmarkName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the level. This will append a changelevel command to the server command buffer. Calling pfnServerExecute will trigger the changelevel. Subsequent calls made during the same map will be ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszLevelName</td><td>Name of the level to change to. </td></tr>
    <tr><td class="paramname">pszLandmarkName</td><td>Name of the landmark to use. If null, no landmark is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f24e56a340e98168c21cce9f40ba202"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnChangePitch) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the entity's pitch angle to approach its ideal pitch. Yaw is updated at <a class="el" href="structentvars__t.html#a7e8c483d71faee568e065c4da615a500">entvars_t::pitch_speed</a> speed to match <a class="el" href="structentvars__t.html#a55efe637ba7a6c473c5da9869ceb2c85">entvars_t::idealpitch</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> whose pitch is to be changed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66402efb49b709895f5afb18e9e89a0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnChangeYaw) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the entity's yaw angle to approach its ideal yaw. Yaw is updated at <a class="el" href="structentvars__t.html#a5521e17c0be4f83b552bb950b7024d50">entvars_t::yaw_speed</a> speed to match <a class="el" href="structentvars__t.html#ac24350e4daef217260799be8dc2c3d2c">entvars_t::ideal_yaw</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> whose yaw is so be changed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fed4a596079b9e4b140b4121b18c9ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnCheckParm) (const char *pszCmdLineToken, char **ppNext)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a command line parameter was provided. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszCmdLineToken</td><td>Command key to look for. </td></tr>
    <tr><td class="paramname">ppNext</td><td>If the key was found, this is set to the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Key index in the command line buffer, or 0 if it wasn't found. </dd></dl>

</div>
</div>
<a class="anchor" id="a257d7e579dbb39a5304203020bf2d2d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnCheckVisibility) (const <a class="el" href="structedict__t.html">edict_t</a> *pEntity, unsigned char *pVisibleSet)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the given entity is visible in the given visible set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> to check. </td></tr>
    <tr><td class="paramname">pVisibleSet</td><td>Buffer detailing the current visible set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the given entity is visible in the given visible set. </dd></dl>

</div>
</div>
<a class="anchor" id="a5cf5925e5429f358d8096f010d3f4223"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnClientCommand) (<a class="el" href="structedict__t.html">edict_t</a> *pEdict, const char *pszFormat,...)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends a client command to the given client. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdict</td><td>Edict of the client that should execute the command. </td></tr>
    <tr><td class="paramname">pszFormat</td><td>Format string. </td></tr>
    <tr><td class="paramname">...</td><td>Format arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae012771231ab7346f1129b5a6a43b5d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnClientPrintf) (<a class="el" href="structedict__t.html">edict_t</a> *pEdict, <a class="el" href="eiface_8h.html#a0d9a05d88ef681f9a1e7d362f6f20ac1">PRINT_TYPE</a> pType, const char *pszMessage)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends a message to the client console. print_chat outputs to the console, just as print_console. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdict</td><td>Client to send the message to. </td></tr>
    <tr><td class="paramname">pType</td><td>Where to print the message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="eiface_8h.html#a0d9a05d88ef681f9a1e7d362f6f20ac1">PRINT_TYPE</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszMessage</td><td>Message to send. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d18d17c26875c41a929f9e2ad6b237e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnCmd_Argc) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of command arguments. This includes the command name. </dd></dl>

</div>
</div>
<a class="anchor" id="a3dd2ae76c7bda444b69be84818d3feaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char*(* enginefuncs_t::pfnCmd_Args) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespace_string.html">String</a> containing all of the command arguments, not including the command name. </dd></dl>

</div>
</div>
<a class="anchor" id="a20c467675fbc85972742de722f5ce875"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char*(* enginefuncs_t::pfnCmd_Argv) (int argc)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the command argument at the given index. Argument 0 is the command name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>Argument index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Command argument. </dd></dl>

</div>
</div>
<a class="anchor" id="a4477b95722bcf422c2ed03a9dac221c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnCompareFileTime) (const char *pszFilename1, const char *pszFilename2, int *piCompare)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares file times. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename1</td><td>First file to compare. </td></tr>
    <tr><td class="paramname">pszFilename2</td><td>Second file to compare. </td></tr>
    <tr><td class="paramname">piCompare</td><td>If both files are equal, 0. If the first file is older, -1. If the second file is older, 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both filenames are non-null, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f9631abf18d7802f9e071d165e2985d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="crc_8h.html#ac7476db75bdc35bc021d17ec36e17cbd">CRC32_t</a>(* enginefuncs_t::pfnCRC32_Final) (<a class="el" href="crc_8h.html#ac7476db75bdc35bc021d17ec36e17cbd">CRC32_t</a> pulCRC)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finalizes the CRC instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pulCRC</td><td>CRC instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CRC value. </dd></dl>

</div>
</div>
<a class="anchor" id="a51843cef3802474c87bb9c9ae48358a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnCRC32_Init) (<a class="el" href="crc_8h.html#ac7476db75bdc35bc021d17ec36e17cbd">CRC32_t</a> *pulCRC)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the CRC instance. </p>

</div>
</div>
<a class="anchor" id="a8f4f27f6ccca5c1043a2d2fd2e445fe1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnCRC32_ProcessBuffer) (<a class="el" href="crc_8h.html#ac7476db75bdc35bc021d17ec36e17cbd">CRC32_t</a> *pulCRC, void *pBuffer, int len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Processes a buffer and updates the CRC. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pulCRC</td><td>CRC instance. </td></tr>
    <tr><td class="paramname">pBuffer</td><td>Buffer to process. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes in the buffer to process. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad265bc2315c1e8a3822f0dacbc7223e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnCRC32_ProcessByte) (<a class="el" href="crc_8h.html#ac7476db75bdc35bc021d17ec36e17cbd">CRC32_t</a> *pulCRC, unsigned char ch)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Processes a single byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pulCRC</td><td>CRC instance. </td></tr>
    <tr><td class="paramname">ch</td><td>Byte. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a626c8bc9da07532bf97dde73faf1f0c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structedict__t.html">edict_t</a>*(* enginefuncs_t::pfnCreateEntity) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an edict for use with an entity. If the engine is out of edicts, triggers a sys error. If the engine is not ready for entity instantiation yet (e.g. during restore), triggers a sys error. </p><dl class="section return"><dt>Returns</dt><dd>Newly allocated edict. </dd></dl>

</div>
</div>
<a class="anchor" id="a72020defed33477c4d6f1fc3aeb962b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structedict__t.html">edict_t</a>*(* enginefuncs_t::pfnCreateFakeClient) (const char *pszNetName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a fake client (bot). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszNetName</td><td>Name of the client to show. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fake client, or null if it can't be created. </dd></dl>

</div>
</div>
<a class="anchor" id="a1da4235cde80c7b7f810d425aa126d26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnCreateInstancedBaseline) (<a class="el" href="const_8h.html#a8b54a01f6c8e1ccdad69c14a181c3d45">string_t</a> iszClassName, <a class="el" href="structentity__state__t.html">entity_state_t</a> *baseline)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an instanced baseline. Used to define a baseline for a particular entity type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iszClassName</td><td>Name of the entity class. </td></tr>
    <tr><td class="paramname">baseline</td><td>Baseline to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e45a16dcbfabe4b810d414c888412e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structedict__t.html">edict_t</a>*(* enginefuncs_t::pfnCreateNamedEntity) (<a class="el" href="const_8h.html#a8b54a01f6c8e1ccdad69c14a181c3d45">string_t</a> iszClassName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an entity of the class iszClassName. Note: this will not fall back to invoking the custom entity handler if the given class does not exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iszClassName</td><td>Name of the class to instantiate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Edict of the entity that was instantiated, or null if no such entity exists. </dd></dl>

</div>
</div>
<a class="anchor" id="a375c321d3ea645e20550be3f61b1fece"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnCrosshairAngle) (const <a class="el" href="structedict__t.html">edict_t</a> *pClient, float pitch, float yaw)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the angles of the given player's crosshairs to the given settings. Set both to 0 to disable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pClient</td><td>Client whose crosshair settings should be set. </td></tr>
    <tr><td class="paramname">pitch</td><td>Pitch. </td></tr>
    <tr><td class="paramname">yaw</td><td>Yaw. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fbbb39a111d952c8f2cfb10e6990e19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnCvar_DirectSet) (<a class="el" href="structcvar__t.html">cvar_t</a> *pCvar, const char *pszValue)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Directly sets a cvar value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCvar</td><td>Cvar. </td></tr>
    <tr><td class="paramname">pszValue</td><td>Value to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac321f32b3540b5d7519cfb711eaaa827"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnCvar_RegisterVariable) (<a class="el" href="structcvar__t.html">cvar_t</a> *variable)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a Cvar. Identical to CvarRegister, except it doesn't set the FCVAR_EXTDLL flag. </p>

</div>
</div>
<a class="anchor" id="a63d9959aa10cab0018c2e83e94470de4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float(* enginefuncs_t::pfnCVarGetFloat) (const char *pszVarName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the value of a cvar as a float. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszVarName</td><td>Name of the cvar whose value is to be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the cvar, or 0 if the cvar doesn't exist. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d383e4a3ef5c0c33b36dbc72688d09f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcvar__t.html">cvar_t</a>*(* enginefuncs_t::pfnCVarGetPointer) (const char *pszVarName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszVarName</td><td>Name of the cvar to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cvar pointer, or null if the cvar doesn't exist. </dd></dl>

</div>
</div>
<a class="anchor" id="a920afe54710bfd77200047734e887c2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char*(* enginefuncs_t::pfnCVarGetString) (const char *pszVarName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the value of a cvar as a string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszVarName</td><td>Name of the cvar whose value is to be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the cvar, or an empty string if the cvar doesn't exist. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9863bd16e65b684325e8e1c6c9b1ddf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnCVarRegister) (<a class="el" href="structcvar__t.html">cvar_t</a> *pCvar)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a cvar. Sets the flag FCVAR_EXTDLL on the cvar. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCvar</td><td>Cvar to register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaddd3d6f190c77e2e9035369ec7eb792"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnCVarSetFloat) (const char *pszVarName, float flValue)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the value of a cvar as a float. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszVarName</td><td>Name of the cvar whose value to set. </td></tr>
    <tr><td class="paramname">flValue</td><td>Value to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e6e1a18e2dc1195d7614e0e2d34ec0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnCVarSetString) (const char *pszVarName, const char *pszValue)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the value of a cvar as a string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszVarName</td><td>Name of the cvar whose value to set. </td></tr>
    <tr><td class="paramname">pszValue</td><td>Value to set. The string is copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf9ed5a5722a32dcb9fbded7d33a114b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnDecalIndex) (const char *pszName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the index of the given decal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>Name of the decal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the decal, or -1 if the decal couldn't be found. </dd></dl>

</div>
</div>
<a class="anchor" id="ac14cd05df97eeca2679979a329473cc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnDeltaAddEncoder) (const char *const pszName, void(*conditionalencode)(delta_t *pFields, const unsigned char *from, const unsigned char *to))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a delta encoder. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>Name of the delta.lst entry to add the encoder for. </td></tr>
    <tr><td class="paramname">conditionalencode</td><td>Encoder function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b2f77756e10abf47e60216f7d6781e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnDeltaFindField) (delta_t *pFields, const char *pszFieldName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the index of a delta field. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFields</td><td>List of fields. </td></tr>
    <tr><td class="paramname">pszFieldName</td><td>Name of the field to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the delta field, or -1 if the field couldn't be found. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ec820d28a9a2bd63f07e1b5fb806608"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnDeltaSetField) (delta_t *pFields, const char *pszFieldName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks the given field in the given list as set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFields</td><td>List of fields. </td></tr>
    <tr><td class="paramname">pszFieldName</td><td>Field name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b818ddc23fe08913b88adf010500253"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnDeltaSetFieldByIndex) (delta_t *pFields, int fieldNumber)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks a delta field as set by index. If the index is invalid, causes illegal access. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFields</td><td>List of fields. </td></tr>
    <tr><td class="paramname">fieldNumber</td><td>Index of the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0da5d7c31e2dd3d4e39712d4eb10e62f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnDeltaUnsetField) (delta_t *pFields, const char *pszFieldName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks the given field in the given list as not set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFields</td><td>List of fields. </td></tr>
    <tr><td class="paramname">pszFieldName</td><td>Field name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7c9c041465c1b0c3802cec12fc45d77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnDeltaUnsetFieldByIndex) (delta_t *pFields, int fieldNumber)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks a delta field as not set by index. If the index is invalid, causes illegal access. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFields</td><td>List of fields. </td></tr>
    <tr><td class="paramname">fieldNumber</td><td>Index of the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3fe8e47e89ac93716d31f8b7f5f43cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnDropToFloor) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Drops the entity to the floor. The entity will be moved down to the floor, effectively being teleported.</p>
<p>Note: maximum drop distance is 256 units. If the floor is further than that away, the entity will not be moved. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> to drop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the entity is stuck inside a solid object. 0 if the floor is further than 256 units away. 1 if the entity was dropped to the floor. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6c59fdfc860322fdad9570bb65c9430"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnEmitAmbientSound) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity, const <a class="el" href="class_vector.html">Vector</a> &amp;vecPos, const char *pszSample, float vol, float attenuation, int fFlags, int pitch)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Emits a sounds from the given entity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> that is emitting the sound. </td></tr>
    <tr><td class="paramname">vecPos</td><td>Position in the world to play the sound at. </td></tr>
    <tr><td class="paramname">pszSample</td><td>Sample to play. The sound must be precached. </td></tr>
    <tr><td class="paramname">volume</td><td>Sound volume. Must be a value in the range [ 0, 1 ]. </td></tr>
    <tr><td class="paramname">attenuation</td><td>Sound attenuation. </td></tr>
    <tr><td class="paramname">fFlags</td><td>Sound flags. </td></tr>
    <tr><td class="paramname">pitch</td><td>Sound pitch. Must be a value in the range [ 0, 255 ]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedd778189a8b42b85124e20cc2ec6eda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnEmitSound) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity, int channel, const char *pszSample, float volume, float attenuation, int fFlags, int pitch)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Emits a sounds from the given entity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> that is emitting the sound. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel to play the sound on. </td></tr>
    <tr><td class="paramname">pszSample</td><td>Sample to play. The sound must be precached. </td></tr>
    <tr><td class="paramname">volume</td><td>Sound volume. Must be a value in the range [ 0, 1 ]. </td></tr>
    <tr><td class="paramname">attenuation</td><td>Sound attenuation. </td></tr>
    <tr><td class="paramname">fFlags</td><td>Sound flags. </td></tr>
    <tr><td class="paramname">pitch</td><td>Sound pitch. Must be a value in the range [ 0, 255 ]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ded806c92f451fe617413b9c2e91fe9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnEndSection) (const char *pszSectionName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signals the engine that a section has ended. Possible values: _oem_end_training _oem_end_logo _oem_end_demo</p>
<p>A disconnect command is sent by this call. </p>

</div>
</div>
<a class="anchor" id="a2e067f347fbd5fcf5a09c167ec77ac13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnEngineFprintf) (void *pFile, const char *pszFormat,...)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obsolete. Will print a message to the server console using pfnAlertMessage indicating if it's being used. </p>

</div>
</div>
<a class="anchor" id="a8bbad015f14bfb3defc6e6e394b875f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnEntIsOnFloor) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether the given entity is on the floor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the entity is on the floor, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aec103b29f86a80950d401b6a2e2e0e3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structedict__t.html">edict_t</a>*(* enginefuncs_t::pfnEntitiesInPVS) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find entities in Potentially Visible Set. This builds a list of entities using <a class="el" href="structentvars__t.html#a572569de6b82e8e2e93ec7d117fa8a9e">entvars_t::chain</a>. This list is temporary, so store its results elsewhere if it is needed later on.</p>
<p>Note: this operation is expensive as it checks every entity. Avoid using this unless it is absolutely necessary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> whose origin and view offset should be used to determine which entities are visible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>First entity in the chain of entities that are visible, or worldspawn if no entities are visible. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c2dc7591944b388641e19f112b48c94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="eiface_8h.html#a27688f71f76eaf06690fc420a6666076">EOFFSET</a>(* enginefuncs_t::pfnEntOffsetOfPEntity) (const <a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the entity offset of the edict. DO NOT USE THIS. Use pfnIndexOfEdict. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdict</td><td>Edict whose offset is to be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespace_entity.html">Entity</a> offset. </dd></dl>

</div>
</div>
<a class="anchor" id="a34be044631214fe6cb1a99b43d498312"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnFadeClientVolume) (const <a class="el" href="structedict__t.html">edict_t</a> *pEdict, int fadePercent, int fadeOutSeconds, int holdTime, int fadeInSeconds)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fades the given client's volume. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdict</td><td>Client. </td></tr>
    <tr><td class="paramname">fadePercent</td><td>Percentage volume to fade out to. </td></tr>
    <tr><td class="paramname">fadeOutSeconds</td><td>How long it takes to fade out, in seconds. </td></tr>
    <tr><td class="paramname">holdTime</td><td>How long to stay faded out, in seconds. </td></tr>
    <tr><td class="paramname">fadeInSeconds</td><td>How long it takes to fade in, in seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ea676484576c8b73e2cb07d0696a9c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structedict__t.html">edict_t</a>*(* enginefuncs_t::pfnFindClientInPVS) (const <a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds a client in the Potentially Visible Set. Returns the world if no client could be found in the entity's PVS. This function's behavior is unexpected: it will get the next client every 0.1 seconds, and check if the entity can see it. If so, the client is returned. Otherwise, the world is returned. Use FNullEnt to check if the result is a valid client. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdict</td><td><a class="el" href="namespace_entity.html">Entity</a> whose origin and view offset should be used to determine which client is visible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Client, or null if no client could be found. </dd></dl>

</div>
</div>
<a class="anchor" id="a518e79c3711854ab2a64a6a126a9e072"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structedict__t.html">edict_t</a>*(* enginefuncs_t::pfnFindEntityByString) (<a class="el" href="structedict__t.html">edict_t</a> *pEdictStartSearchAfter, const char *pszField, const char *pszValue)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds an entity by comparing strings. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdictStartSearchAfter</td><td>Edict to start searching after. </td></tr>
    <tr><td class="paramname">pszField</td><td><a class="el" href="namespace_entity.html">Entity</a> field to compare. Only string fields in <a class="el" href="structentvars__t.html">entvars_t</a> are considered. </td></tr>
    <tr><td class="paramname">pszValue</td><td>Value to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the given field exists, and the given value is not null, and an entity has a matching value, returns the edict of that entity. Otherwise, returns null. </dd></dl>

</div>
</div>
<a class="anchor" id="a8eb58e4431428d1672b15bdae45be519"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structedict__t.html">edict_t</a>*(* enginefuncs_t::pfnFindEntityByVars) (<a class="el" href="structentvars__t.html">entvars_t</a> *pVars)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the edict of an entvars. This will enumerate all entities, so this operation can be very expensive. Use pVars-&gt;pContainingEntity if possible. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pVars</td><td>Entvars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Edict. </dd></dl>

</div>
</div>
<a class="anchor" id="af226c43a9f436e744b5e226aa3d7fb1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structedict__t.html">edict_t</a>*(* enginefuncs_t::pfnFindEntityInSphere) (<a class="el" href="structedict__t.html">edict_t</a> *pEdictStartSearchAfter, const <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin, float rad)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds an entity in a sphere. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdictStartSearchAfter</td><td>Edict to start searching after. </td></tr>
    <tr><td class="paramname">vecOrigin</td><td>Origin in the world to center the sphere around. </td></tr>
    <tr><td class="paramname">rad</td><td>Sphere radius. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first valid entity in the sphere's radius, or null if no entity can be found. </dd></dl>

</div>
</div>
<a class="anchor" id="a5012e7fd0074a69b9153bed00d58b714"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnForceUnmodified) (<a class="el" href="eiface_8h.html#aa333c14e3f31249bd181abd7b2d656d2">FORCE_TYPE</a> type, const float *mins, const float *maxs, const char *pszFilename)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0be10d8ec96b158c0adaa8235dcb9d99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnFreeEntPrivateData) (<a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the <a class="el" href="class_c_base_entity.html">CBaseEntity</a> memory assigned to pEdict. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdict</td><td><a class="el" href="namespace_entity.html">Entity</a> whose memory should be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a658654ce21a9eb55055a8b4ab036fc94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnFreeFile) (void *pBuffer)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the buffer provided by pfnLoadFileForMe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuffer</td><td>Pointer to buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structenginefuncs__t.html#a01cbba541725146d671768046fa162a2">pfnLoadFileForMe</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a09b5187ad35fdd2e09caa486f1d287c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="const_8h.html#a615188600515ea51267daa7198237405">func_t</a>(* enginefuncs_t::pfnFunctionFromName) (const char *pszName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the index of an exported function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>Name of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the function, or 0 if the function couldn't be found. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0b13def219573b1a6f7fa4b69aa6ecd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnGetAimVector) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity, float speed, <a class="el" href="class_vector.html">Vector</a> &amp;vecReturn)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the aim vector for the given entity Assumes MakeVectors was called with pEntity-&gt;v.angles beforehand.</p>
<p>The aim vector is the autoaim vector used when sv_aim is enabled. It will snap to entities that are close to the entity's forward vector axis. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> to retrieve the aim vector for. </td></tr>
    <tr><td class="paramname">speed</td><td>Unused. </td></tr>
    <tr><td class="paramname">vecReturn</td><td>The resulting aim vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab7c594b7141a80a57823f3e60d951895"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int(* enginefuncs_t::pfnGetApproxWavePlayLen) (const char *pszFilePath)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the average wave length in seconds. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilePath</td><td>Name of the sound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the sound file, in seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="a9fdab964f9a6c55bac79c9ba82272f0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnGetAttachment) (const <a class="el" href="structedict__t.html">edict_t</a> *pEdict, int iAttachment, <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin, <a class="el" href="class_vector.html">Vector</a> &amp;vecAngles)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the attachment origin and angles. If the entity is null, or does not have a studio model, illegal access will occur. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdict</td><td><a class="el" href="namespace_entity.html">Entity</a> whose model will be queried for the attachment data. </td></tr>
    <tr><td class="paramname">iAttachment</td><td>Attachment index. </td></tr>
    <tr><td class="paramname">vecOrigin</td><td>Attachment origin. </td></tr>
    <tr><td class="paramname">vecAngles</td><td>Attachment angles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4fbb21247d9f726c5b1fea8236afb07e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnGetBonePosition) (const <a class="el" href="structedict__t.html">edict_t</a> *pEdict, int iBone, <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin, <a class="el" href="class_vector.html">Vector</a> &amp;vecAngles)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the bone position and angles for the given entity and bone. If the given entity is invalid, or does not have a studio model, or the bone index is invalid, will cause invalid accesses to occur. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdict</td><td><a class="el" href="namespace_entity.html">Entity</a> whose model should be queried. </td></tr>
    <tr><td class="paramname">iBone</td><td>Bone index. </td></tr>
    <tr><td class="paramname">vecOrigin</td><td>Origin of the bone. </td></tr>
    <tr><td class="paramname">vecAngles</td><td>Angles of the bone. Is not set by the engine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54696e00893179cbc1989eacfacacaf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnGetCurrentPlayer) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The client index of the client that is currently being handled by an engine callback. Returns -1 if no client is currently being handled. </dd></dl>

</div>
</div>
<a class="anchor" id="a6641de1e58d2ece0b5e1abe2c5afd1f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnGetEntityIllum) (<a class="el" href="structedict__t.html">edict_t</a> *pEnt)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEnt</td><td><a class="el" href="namespace_entity.html">Entity</a> whose light value is to be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the given entity is null, returns -1. If the given entity is a client or the world, returns <a class="el" href="structentvars__t.html#a9acbd7953b6771ba307e22c8e1543536">entvars_t::light_level</a>. Otherwise, returns the color of the floor that the entity is standing on. </dd></dl>

</div>
</div>
<a class="anchor" id="a930aca9d0b58159674cdbb4c24ac4e35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnGetFileSize) (const char *pszFileName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LH: Give access to filesize via filesystem </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFileName</td><td>Name of the file whose size is to be queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>File size, or -1 if the file doesn't exist. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7128bdb28188b8a633bc33d55efa63e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnGetGameDir) (char *pszGetGameDir)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the game directory name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszGetGameDir</td><td>Buffer to store the game directory name in. Must be at least MAX_PATH bytes large. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0827c1c1fc1858e0fd8f0fad6a9d9503"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char*(* enginefuncs_t::pfnGetInfoKeyBuffer) (<a class="el" href="structedict__t.html">edict_t</a> *pClient)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the given client's info key buffer. Passing in the world gets the serverinfo. Passing in null gets the localinfo. Localinfo is not used by the engine itself, only the game. Note: this function checks the maxplayers value incorrectly and may crash if the wrong edict gets passed in. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pClient</td><td>Client. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Info key buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4252f3735c548b622bf7c0aabf596f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnGetLocalizedStringLength) (const char *pszLabel)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>BGC </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszLabel</td><td>Label </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters of the localized string referenced by using "pszLabel". </dd></dl>

</div>
</div>
<a class="anchor" id="a8cd5612ce8d95a534d362165416369dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* enginefuncs_t::pfnGetModelPtr) (<a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the model pointer of the given entity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdict</td><td><a class="el" href="namespace_entity.html">Entity</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the model, or null if the entity doesn't have one. Triggers a sys error if the model wasn't loaded and couldn't be loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="a475d46b21ace17d7f001ab5f7f1c590c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char*(* enginefuncs_t::pfnGetPhysicsInfoString) (const <a class="el" href="structedict__t.html">edict_t</a> *pClient)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the physics info string for the given client. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pClient</td><td>whose buffer will be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Buffer, or an empty string if the client is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="afafa492c5508c9038ef91947cc4f4c41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char*(* enginefuncs_t::pfnGetPhysicsKeyValue) (const <a class="el" href="structedict__t.html">edict_t</a> *pClient, const char *pszKey)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the given physics keyvalue from the given client's buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pClient</td><td>Client whose buffer will be queried. </td></tr>
    <tr><td class="paramname">pszKey</td><td>Key whose value will be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value, or an empty string if the key does not exist. </dd></dl>

</div>
</div>
<a class="anchor" id="a74bc51e64c4368e9513342a5dc41cdfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char*(* enginefuncs_t::pfnGetPlayerAuthId) (const <a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the player's auth ID. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdict</td><td>Client. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The player's auth ID, or an empty string. This points to a temporary buffer, copy the results. </dd></dl>

</div>
</div>
<a class="anchor" id="a32a86bb2a43d77656f171250641ce61c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnGetPlayerStats) (const <a class="el" href="structedict__t.html">edict_t</a> *pClient, int *piPing, int *piPacket_loss)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get player statistics. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pClient</td><td>Client to query. </td></tr>
    <tr><td class="paramname">piPing</td><td>Current ping. </td></tr>
    <tr><td class="paramname">piPacket_loss</td><td>Current packet loss, measured in percentage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa16cfc2315fff39a15270222457f2270"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnGetPlayerUserId) (<a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the server assigned userid for this player. Useful for logging frags, etc. Returns -1 if the edict couldn't be found in the list of clients. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdict</td><td>Client. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>User ID, or -1. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b287aecb46c9e710444e2350136cb7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int(* enginefuncs_t::pfnGetPlayerWONId) (<a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the server assigned WONid for this player. Useful for logging frags, etc. Returns -1 if the edict couldn't be found in the list of clients. Always returns -1 when using the Steam version. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdict</td><td>Client. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>WON ID, or -1. </dd></dl>

</div>
</div>
<a class="anchor" id="a25768848bf9768a692ded928c03fed12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnGetSpawnParms) (<a class="el" href="structedict__t.html">edict_t</a> *pClient)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does nothing useful. Will trigger a host error if the given entity is not a client. </p>

</div>
</div>
<a class="anchor" id="a3c46053284d0177ab72e77fed96be6c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnGetTimesTutorMessageShown) (int iMessageID)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the number of times the message with the given ID has been shown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iMessageID</td><td>Message ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of times the message with the given ID has been shown. </dd></dl>

</div>
</div>
<a class="anchor" id="a1408ef071c4c2479f331e5f0744d5fac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentvars__t.html">entvars_t</a>*(* enginefuncs_t::pfnGetVarsOfEnt) (<a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the <a class="el" href="structentvars__t.html">entvars_t</a> instance assigned to the given <a class="el" href="structedict__t.html">edict_t</a> instance. In effect, returns &amp;pEdict-&gt;v. If pEdict is null, causes a crash. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdict</td><td>Edict whose entvars is to be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>entvars. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a127082954a30e2b7d046fbfb9d346c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnIndexOfEdict) (const <a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the entity index of the edict. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdict</td><td>Edict whose entity index is to be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If pEdict is null, returns 0. If pEdict is not managed by the engine, triggers a sys error. Otherwise, returns the entity index. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e4481fbd6a6fc244af2392cc41c085d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnInfo_RemoveKey) (char *pszInfoBuffer, const char *pszKey)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a key from the info buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszInfoBuffer</td><td>Buffer to modify. </td></tr>
    <tr><td class="paramname">pszKey</td><td>Key to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1c1b7394ee2901223b41626da260396"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char*(* enginefuncs_t::pfnInfoKeyValue) (const char *pszInfoBuffer, const char *pszKey)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the value of the given key from the given buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszInfoBuffer</td><td>Buffer to query. </td></tr>
    <tr><td class="paramname">pszKey</td><td>Key whose value to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested value, or an empty string. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5ebe49940989605ba0d962d7cd9a522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnIsCareerMatch) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether this is a Condition Zero Career match. </dd></dl>

</div>
</div>
<a class="anchor" id="addad0e7fa3fb5033cd6e20386015f3c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnIsDedicatedServer) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether this is a dedicated server. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d7fd1de9002f9a5830a8559cd840b3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnIsMapValid) (const char *pszFilename)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the given filename is a valid map. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>Name of the map to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the map is valid, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d52525919ab5cc661dea7bf1828a2fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnLightStyle) (int style, const char *val)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given light style to the given value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">style</td><td>Style index. </td></tr>
    <tr><td class="paramname">val</td><td>Value to set. This string must live for at least as long as the map itself. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01cbba541725146d671768046fa162a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="const_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>*(* enginefuncs_t::pfnLoadFileForMe) (const char *pszFilename, int *pLength)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads a file from disk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>Name of the file. Path starts in the game directory. </td></tr>
    <tr><td class="paramname">pLength</td><td>If not null, is set to the size of the file, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the file buffer, or null if the file could not be loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9d700b7e89687303023f5a2f066f837"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnMakeStatic) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an entity static. Static entities are copied to the client side and are removed on the server side. Only valid during map spawn. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> to make static. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add3f35ab00e1327b4a47bcae7b767ccd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnMakeVectors) (const <a class="el" href="class_vector.html">Vector</a> &amp;vecVector)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make direction vectors from angles. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecVector</td><td>Angles to convert to direction vectors. The results are stored in gpGlobals-&gt;v_forward, gpGlobals-&gt;v_right and gpGlobals-&gt;v_up. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66d8e917da3498a3374fc1f961922268"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnMessageBegin) (int iMsgType, int iMsgID, const float *pOrigin, <a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Begins a new network message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iMsgType</td><td>Message type. Used to be called msg_dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="const_8h.html#a81e963d13a00ec761f3cd16507fe0cf3">NetMessageType</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iMsgID</td><td>Message ID. Used to be called msg_type. </td></tr>
    <tr><td class="paramname">pOrigin</td><td>Optional. Origin to use for PVS and PAS checks. </td></tr>
    <tr><td class="paramname">pEdict</td><td>Optional. If it's a message to one client, client to send the message to.</td></tr>
  </table>
  </dd>
</dl>
<p>If the message type is to one client, and no client is provided, triggers a sys error. If the message type is to all clients, and a client is provided, triggers a sys error. If another message had already been started and was not ended, triggers a sys error. If an invalid message ID is provided, triggers a sys error. </p>

</div>
</div>
<a class="anchor" id="ad64a1e947dab6f8a5e46c450bbbbe679"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnMessageEnd) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ends a network message.</p>
<p>If no message had been started, triggers a sys error. If the buffer had overflowed, triggers a sys error. If the message is a user message, and exceeds 192 bytes, triggers a host error. If the message has a fixed size and the wrong size was written, triggers a sys error. If the given client is invalid, triggers a host error. </p>

</div>
</div>
<a class="anchor" id="a812850f1367c910a1a0305719c0d326b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnModelFrames) (int modelIndex)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the number of frames in the given model. If this is a sprite, returns the number of sprite frames. If this is a studio model, this is all of the submodels in each body part multiplied with each-other. It represents the number of variations that can be created by changing submodels (e.g. heads, weapons, etc). Otherwise, returns 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modelIndex</td><td>Index of the model whose frame count is to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Frame count of the model. </dd></dl>

</div>
</div>
<a class="anchor" id="a7044872292188d6a12b8ceb2b988ccd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnModelIndex) (const char *pszModelName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the index of the given model. If the given model was not precached, shuts the game down. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszModelName</td><td>Name of the model whose index is to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the model. </dd></dl>

</div>
</div>
<a class="anchor" id="af42a4d33579cd8e6fbd1d23178d5208b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnMoveToOrigin) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity, const <a class="el" href="class_vector.html">Vector</a> &amp;vecGoal, float dist, int iMoveType)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the given entity to the given destination. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> to move. </td></tr>
    <tr><td class="paramname">vecGoal</td><td>Destination. </td></tr>
    <tr><td class="paramname">dist</td><td>Distance to cover in this movement operation, in units. </td></tr>
    <tr><td class="paramname">iMoveType</td><td>Move type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_monsters_8h.html#a813ed0529ceb1d8a461e827ba5db4c9b">MoveToOrigin</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0c92dc560d09f883a540891f68fe82f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char*(* enginefuncs_t::pfnNameForFunction) (<a class="el" href="const_8h.html#a615188600515ea51267daa7198237405">func_t</a> function)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the name of an exported function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function name, or null if no function exists at that index. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7b8b44c95704c1916ba8f2aad69ea9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnNumberOfEntities) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the total number of entities currently in existence. Note: this will calculate the number of entities in real-time. May be expensive if called many times. </p><dl class="section return"><dt>Returns</dt><dd>Number of entities. </dd></dl>

</div>
</div>
<a class="anchor" id="aca61ed18b6e48d3d1ba91480d4adb046"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnParticleEffect) (const <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin, const <a class="el" href="class_vector.html">Vector</a> &amp;vecDir, float color, float count)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a particle effect. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecOrigin</td><td>Origin in the world. </td></tr>
    <tr><td class="paramname">vecDir</td><td>Direction of the effect. </td></tr>
    <tr><td class="paramname">color</td><td><a class="el" href="struct_color.html">Color</a> of the effect. </td></tr>
    <tr><td class="paramname">count</td><td>Number of particles to create. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70975629f061f5d6a9e022ea9585fcae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structedict__t.html">edict_t</a>*(* enginefuncs_t::pfnPEntityOfEntIndex) (int iEntIndex)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the edict at the given entity index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iEntIndex</td><td><a class="el" href="namespace_entity.html">Entity</a> index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the given index is not valid, returns null. Otherwise, if the entity at the given index is not in use, returns null. Otherwise, if the entity at the given index is not a player and does not have a <a class="el" href="class_c_base_entity.html">CBaseEntity</a> instance, returns null. Otherwise, returns the entity. </dd></dl>

</div>
</div>
<a class="anchor" id="ab261f04510bce272412ff7d1cd4af7d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structedict__t.html">edict_t</a>*(* enginefuncs_t::pfnPEntityOfEntOffset) (<a class="el" href="eiface_8h.html#a27688f71f76eaf06690fc420a6666076">EOFFSET</a> iEntOffset)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets an edict by offset. This uses the byte offset of the edict to retrieve it. DO NOT USE THIS. Use pfnPEntityOfEntIndex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iEntOffset</td><td><a class="el" href="namespace_entity.html">Entity</a> offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Edict at the given offset. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ae4216d68b6d459de995a7272ffa578"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnPlaybackEvent) (int flags, const <a class="el" href="structedict__t.html">edict_t</a> *pInvoker, unsigned short eventindex, float delay, const <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin, const <a class="el" href="class_vector.html">Vector</a> &amp;vecAngles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Event flags. </td></tr>
    <tr><td class="paramname">pInvoker</td><td>Client that triggered the event. </td></tr>
    <tr><td class="paramname">eventindex</td><td>Event index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structenginefuncs__t.html#adf40676e8f8c4ff14380f94b67da489a">pfnPrecacheEvent</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>Delay before the event should be run. </td></tr>
    <tr><td class="paramname">vecOrigin</td><td>If not g_vecZero, this is the origin parameter sent to the clients. </td></tr>
    <tr><td class="paramname">vecAngles</td><td>If not g_vecZero, this is the angles parameter sent to the clients. </td></tr>
    <tr><td class="paramname">fparam1</td><td>Float parameter 1. </td></tr>
    <tr><td class="paramname">fparam2</td><td>Float parameter 2. </td></tr>
    <tr><td class="paramname">iparam1</td><td>Integer parameter 1. </td></tr>
    <tr><td class="paramname">iparam2</td><td>Integer parameter 2. </td></tr>
    <tr><td class="paramname">bparam1</td><td>Boolean parameter 1. </td></tr>
    <tr><td class="paramname">bparam2</td><td>Boolean parameter 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d35da21d3db362bd4654bea5dd3ab5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnPointContents) (const <a class="el" href="class_vector.html">Vector</a> &amp;vecVector)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the contents of the given location in the world. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecVector</td><td>Location in the world. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Contents of the location in the world. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="const_8h.html#a3f2b2573232beed5f606300da95ac0b2">Contents</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adf40676e8f8c4ff14380f94b67da489a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short(* enginefuncs_t::pfnPrecacheEvent) (int type, const char *pszEventName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Precaches an event. The client will have to hook the event using <a class="el" href="structcl__enginefunc__t.html#acc23c26b4b6aa02f259d2e69818c58d4">cl_enginefunc_t::pfnHookEvent</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Should always be 1. </td></tr>
    <tr><td class="paramname">pszEventName</td><td>Name of the event. Format should be events/&lt;name&gt;.sc, including the directory and extension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Event index. Used with pfnPlaybackEvent </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcl__enginefunc__t.html#acc23c26b4b6aa02f259d2e69818c58d4">cl_enginefunc_t::pfnHookEvent</a> </dd>
<dd>
<a class="el" href="structenginefuncs__t.html#a2ae4216d68b6d459de995a7272ffa578">pfnPlaybackEvent</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6c27718fb8289e64a47aff6e32153675"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnPrecacheGeneric) (const char *pszFilename)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Precaches a file. If pszFilename is null, is empty or contains an invalid value in the first character, triggers a host error. If the maximum number of generic precacheable resources has been reached, triggers a host error. If this is called after ServerActivate, triggers a host error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>Name of the file to precache. Starts in the game directory. This string must live for at least as long as the map itself. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the file. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b21dbb4e8614ea81d1942636496dd19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnPrecacheModel) (const char *pszModelName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Precaches a model. If pszModelName is null, is empty or contains an invalid value in the first character, triggers a host error. If the maximum number of model precacheable resources has been reached, triggers a host error. If this is called after ServerActivate, triggers a host error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszModelName</td><td>Name of the model to precache. Starts in the game directory. This string must live for at least as long as the map itself. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the model. </dd></dl>

</div>
</div>
<a class="anchor" id="a6126faced4799f6dcdc5af7d681240d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnPrecacheSound) (const char *pszSoundName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Precaches a sound. If pszSoundName is null, is empty or contains an invalid value in the first character, triggers a host error. If the maximum number of sound precacheable resources has been reached, triggers a host error. If this is called after ServerActivate, triggers a host error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszSoundName</td><td>Name of the sound to precache. Starts in the sound/ directory. This string must live for at least as long as the map itself. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the sound. </dd></dl>

</div>
</div>
<a class="anchor" id="a4312ea356ecec077fc57c63c4acc8dc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* enginefuncs_t::pfnPvAllocEntPrivateData) (<a class="el" href="structedict__t.html">edict_t</a> *pEdict, <a class="el" href="steamtypes_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> cb)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates memory for <a class="el" href="class_c_base_entity.html">CBaseEntity</a> instances. The memory will be zeroed out. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdict</td><td><a class="el" href="namespace_entity.html">Entity</a> to allocate memory for. </td></tr>
    <tr><td class="paramname">cb</td><td>Number of bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="class_c_base_entity.html">CBaseEntity</a> memory, or null if it could not be allocated. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c32c25a6ba537716efaae2f31e2221c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* enginefuncs_t::pfnPvEntPrivateData) (<a class="el" href="structedict__t.html">edict_t</a> *pEdict)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdict</td><td><a class="el" href="namespace_entity.html">Entity</a> whose entity memory is to be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to entity <a class="el" href="class_c_base_entity.html">CBaseEntity</a> instance, or null if pEdict is null or there is no entity assigned to it. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f9caf89b5940e20594979af1f1db64b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnQueryClientCvarValue) (const <a class="el" href="structedict__t.html">edict_t</a> *pPlayer, const char *pszCvarName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries the given client for a cvar value. The response is sent to <a class="el" href="struct_n_e_w___d_l_l___f_u_n_c_t_i_o_n_s.html#a00575c721079e30ba8e5603860260869">NEW_DLL_FUNCTIONS::pfnCvarValue</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPlayer</td><td>Player to query. </td></tr>
    <tr><td class="paramname">pszCvarName</td><td>Cvar to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a820fbde7433df615253467d6168ea3c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnQueryClientCvarValue2) (const <a class="el" href="structedict__t.html">edict_t</a> *pPlayer, const char *pszCvarName, int requestID)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries the given client for a cvar value. The response is sent to <a class="el" href="struct_n_e_w___d_l_l___f_u_n_c_t_i_o_n_s.html#abb9d3c239418c4282f01f7e034724298">NEW_DLL_FUNCTIONS::pfnCvarValue2</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPlayer</td><td>Player to query. </td></tr>
    <tr><td class="paramname">pszCvarName</td><td>Cvar to query. </td></tr>
    <tr><td class="paramname">requestID</td><td>Request ID to pass to pfnCvarValue2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a5611f60018b3584551c891941c6f7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float(* enginefuncs_t::pfnRandomFloat) (float flLow, float flHigh)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a random float number in the range [ flLow, flHigh ]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flLow</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">flHigh</td><td>Higher bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random number. </dd></dl>

</div>
</div>
<a class="anchor" id="a6197d3002442d15e8517d16c62b69d26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="steamtypes_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>(* enginefuncs_t::pfnRandomLong) (<a class="el" href="steamtypes_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> lLow, <a class="el" href="steamtypes_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> lHigh)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a random long number in the range [ lLow, lHigh ]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lLow</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">lHigh</td><td>Higher bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random number, or lLow if lHigh is smaller than or equal to lLow. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f1b1fc5c3f47c9286f844cb4c549470"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnRegisterTutorMessageShown) (int iMessageID)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks the message with the given ID as having been shown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iMessageID</td><td>Message ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e6133f846451400913a551a7e8d02eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnRegUserMsg) (const char *pszName, int iSize)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a user message. The name of the message is used to find an exported function in the client library. The format is MsgFunc_&lt;name&gt;. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>Name of the message. Maximum length is 12, excluding null terminator. Can be a temporary string. </td></tr>
    <tr><td class="paramname">iSize</td><td>Size of the message, in bytes. Maximum size is 192 bytes. Specify -1 for variable length messages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Message ID, or 0 if the message could not be registered. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d85b6dfd785c3485a0c5e8a115ea5c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnRemoveEntity) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Immediately removes the given entity. Increments the edict serial number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab224bca3f733f19741dbb69f96e15ff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnRunPlayerMove) (<a class="el" href="structedict__t.html">edict_t</a> *fakeclient, const <a class="el" href="class_vector.html">Vector</a> &amp;vecViewangles, float forwardmove, float sidemove, float upmove, unsigned short buttons, <a class="el" href="const_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> impulse, <a class="el" href="const_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> msec)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs player movement for a fake client. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fakeclient</td><td>client to move. Must be a fake client. </td></tr>
    <tr><td class="paramname">vecViewangles</td><td>Client view angles. </td></tr>
    <tr><td class="paramname">forwardmove</td><td>Velocity X value. </td></tr>
    <tr><td class="paramname">sidemove</td><td>Velocity Y value. </td></tr>
    <tr><td class="paramname">upmove</td><td>Velocity Z value. </td></tr>
    <tr><td class="paramname">buttons</td><td>Buttons that are currently pressed in. Equivalent to player pev.button. </td></tr>
    <tr><td class="paramname">impulse</td><td>Impulse commands to execute. Equivalent to player pev.impulse. </td></tr>
    <tr><td class="paramname">msec</td><td>Time between now and previous RunPlayerMove call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5be1b1c8dc8d5d379b42fb11750f68d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnSaveSpawnParms) (<a class="el" href="structedict__t.html">edict_t</a> *pClient)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does nothing useful. Will trigger a host error if the given entity is not a client. Will trigger a sys error if the given entity is invalid. </p>

</div>
</div>
<a class="anchor" id="a9145a911151d80bebfa1bd834840aa27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsequence_entry__t.html">sequenceEntry_t</a>*(* enginefuncs_t::pfnSequenceGet) (const char *pszFileName, const char *pszEntryName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the sequence that has the given entry name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFileName</td><td>Ignored. </td></tr>
    <tr><td class="paramname">pszEntryName</td><td>Entry name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sequence, or null if no such sequence exists. </dd></dl>

</div>
</div>
<a class="anchor" id="a79628bb9d9b9840f6ec6192429e2f81c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsentence_entry__t.html">sentenceEntry_t</a>*(* enginefuncs_t::pfnSequencePickSentence) (const char *pszGroupName, int pickMethod, int *piPicked)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Picks a sentence from the given group. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszGroupName</td><td>Group from which to select a sentence. </td></tr>
    <tr><td class="paramname">pickMethod</td><td>Ignored. </td></tr>
    <tr><td class="paramname">piPicked</td><td>If not null, this is set to the index of the sentence that was picked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sentence that was picked, or null if there is no group by that name, or no sentences in the group. </dd></dl>

</div>
</div>
<a class="anchor" id="afa96b16b3dd3a87c87aaf0696496473a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnServerCommand) (const char *pszCommand)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issues a command to the server. The command must end with either a newline ('<br />
') or a semicolon (';') in order to be considered valid by the engine. The command will be enqueued for execution at a later point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszCommand</td><td>Command to execute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75ce4d5597e908cd0718552e3931b5b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnServerExecute) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Executes all pending server commands. Note: if a changelevel command is in the buffer, this can result in the caller being freed before this call returns. </p>

</div>
</div>
<a class="anchor" id="a6f676ae9a0ebb14495abaa46ed976666"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnServerPrint) (const char *szMsg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends a message to the server console. The message is output regardless of the value of the developer cvar. </p>

</div>
</div>
<a class="anchor" id="a2a280d508e0b9f0419cdeab3b492cc72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnSetClientKeyValue) (int clientIndex, char *pszInfoBuffer, const char *pszKey, char *pszValue)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the value of the given key in the given buffer. This only works for client buffers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clientIndex</td><td><a class="el" href="namespace_entity.html">Entity</a> index of the client. </td></tr>
    <tr><td class="paramname">pszInfoBuffer</td><td>Buffer to modify. </td></tr>
    <tr><td class="paramname">pszKey</td><td>Key whose value to set. </td></tr>
    <tr><td class="paramname">pszValue</td><td>Value to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac39e1c1a497bdd564ad25659f6efd342"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnSetClientMaxspeed) (const <a class="el" href="structedict__t.html">edict_t</a> *pEdict, float flNewMaxspeed)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the client's maximum speed value. Effectively sets pEdict-&gt;v.maxspeed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdict</td><td>Client to set. </td></tr>
    <tr><td class="paramname">flNewMaxspeed</td><td>Maximum speed value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2b30c3ab84034fa163f74cedf91da79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char*(* enginefuncs_t::pfnSetFatPAS) (const <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the Fat Potentially Audible Set buffer to contain data based on the given origin. </p><dl class="section return"><dt>Returns</dt><dd>PAS data. </dd></dl>

</div>
</div>
<a class="anchor" id="a063a4c7d3db0cd428664e19dade1bd61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char*(* enginefuncs_t::pfnSetFatPVS) (const <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the Fat Potentially Visible Set buffer to contain data based on the given origin. </p><dl class="section return"><dt>Returns</dt><dd>PVS data. </dd></dl>

</div>
</div>
<a class="anchor" id="ae63bfbce305e927679b48748f4214133"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnSetGroupMask) (int mask, int op)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to filter contents checks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Mask to check. </td></tr>
    <tr><td class="paramname">op</td><td>Operation to perform during masking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="util_8h.html#af192c54eb98929b904c12f87a7176bea">GroupTraceOp</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7adb348f0adae1e603ad425dca0abc51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnSetKeyValue) (char *pszInfoBuffer, const char *pszKey, char *pszValue)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the value of the given key in the given buffer. If the given buffer is not the localinfo or serverinfo buffer, triggers a sys error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszInfoBuffer</td><td>Buffer to modify. </td></tr>
    <tr><td class="paramname">pszKey</td><td>Key whose value to set. </td></tr>
    <tr><td class="paramname">pszValue</td><td>Value to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2f50bbe622f80f1ecc6faceaf8d8784"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnSetModel) (<a class="el" href="structedict__t.html">edict_t</a> *pEdict, const char *pszModelName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the model of the given entity. Also changes the entity bounds based on the model. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdict</td><td><a class="el" href="namespace_entity.html">Entity</a> to set the model on. </td></tr>
    <tr><td class="paramname">pszModelName</td><td>Name of the model to set. This string must live for at least as long as the map itself. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structenginefuncs__t.html#a0b21dbb4e8614ea81d1942636496dd19">pfnPrecacheModel</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a49bd6475d9a215d2798d48d265b333ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnSetOrigin) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity, const <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the origin of the given entity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> whose origin is to be set. </td></tr>
    <tr><td class="paramname">vecOrigin</td><td>Origin to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3864b2195d2446254aaac2fadf19b90a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnSetPhysicsKeyValue) (const <a class="el" href="structedict__t.html">edict_t</a> *pClient, const char *pszKey, const char *pszValue)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given physics keyvalue in the given client's buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pClient</td><td>Client whose buffer will be modified. </td></tr>
    <tr><td class="paramname">pszKey</td><td>Key whose value will be set. </td></tr>
    <tr><td class="paramname">pszValue</td><td>Value to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f58bdfc25e7cff00f86a9fc00041762"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnSetSize) (<a class="el" href="structedict__t.html">edict_t</a> *pEdict, const <a class="el" href="class_vector.html">Vector</a> &amp;vecMin, const <a class="el" href="class_vector.html">Vector</a> &amp;vecMax)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the entity bounds. Also relinks the entity. <a class="el" href="structentvars__t.html#aeb36b257ce247968b027a1d44ebbee26">entvars_t::mins</a>, <a class="el" href="structentvars__t.html#a91ea42fc34a89bd48c100191fc07daa5">entvars_t::maxs</a> and <a class="el" href="structentvars__t.html#ab2286fef6029ae848b85e08a85fc285c">entvars_t::size</a> are changed. If the bounds are backwards (maxs smaller than mins), a host error is triggered. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdict</td><td><a class="el" href="namespace_entity.html">Entity</a> whose bounds are to be changed. </td></tr>
    <tr><td class="paramname">vecMin</td><td>Minimum relative bounds. </td></tr>
    <tr><td class="paramname">vecMax</td><td>Maximum relative bounds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ace4a58a536eec885aef476e287c2f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnSetView) (const <a class="el" href="structedict__t.html">edict_t</a> *pClient, const <a class="el" href="structedict__t.html">edict_t</a> *pViewent)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the view of a client to the given entity. If pClient is not a client, triggers a host error. Set the view to the client itself to reset it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pClient</td><td>Client whose view is to be set. </td></tr>
    <tr><td class="paramname">pViewent</td><td><a class="el" href="namespace_entity.html">Entity</a> to use as the client's viewpoint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b9007c8c9559d721f9431448c52ae86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnStaticDecal) (const <a class="el" href="class_vector.html">Vector</a> &amp;vecOrigin, int decalIndex, int entityIndex, int modelIndex)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Projects a static decal in the world. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecOrigin</td><td>Origin in the world to project the decal at. </td></tr>
    <tr><td class="paramname">decalIndex</td><td>Index of the decal to project. </td></tr>
    <tr><td class="paramname">entityIndex</td><td>Index of the entity to project the decal onto. </td></tr>
    <tr><td class="paramname">modelIndex</td><td>Index of the model to project the decal onto. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05c4739152b4f8f7b0a84717deb48f0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char*(* enginefuncs_t::pfnSzFromIndex) (<a class="el" href="const_8h.html#a8b54a01f6c8e1ccdad69c14a181c3d45">string_t</a> iString)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the string assigned to the index. If the index is invalid, returns a pointer to invalid memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iString</td><td><a class="el" href="namespace_string.html">String</a> index whose string should be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespace_string.html">String</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0555413d378e2c74c01eb2a3fa49d12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float(* enginefuncs_t::pfnTime) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The time since the first call to Time. Used for delta operations that operate in real world time, as opposed to game world time (which will advance frame by frame, and can be paused). </dd></dl>

</div>
</div>
<a class="anchor" id="a66de34a4fb04fac54187dc24c4eb70ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnTraceHull) (const <a class="el" href="class_vector.html">Vector</a> &amp;vecStart, const <a class="el" href="class_vector.html">Vector</a> &amp;vecEnd, int fNoMonsters, int hullNumber, <a class="el" href="structedict__t.html">edict_t</a> *pentToSkip, <a class="el" href="struct_trace_result.html">TraceResult</a> *ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a trace between a starting and ending position, using the specified hull. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecStart</td><td>Start position. </td></tr>
    <tr><td class="paramname">vecEnd</td><td>End position. </td></tr>
    <tr><td class="paramname">fNoMonsters</td><td>Bit vector containing trace flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="eiface_8h.html#a98a5bd4a96b7775127ba28299f2820ea">TraceLineFlag</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hullNumber</td><td><a class="el" href="namespace_hull.html">Hull</a> to use. </td></tr>
    <tr><td class="paramname">pentToSkip</td><td><a class="el" href="namespace_entity.html">Entity</a> to ignore during the trace. </td></tr>
    <tr><td class="paramname">ptr</td><td><a class="el" href="struct_trace_result.html">TraceResult</a> instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a158d227a8f73eb4b206ed3c882cbc1a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnTraceLine) (const <a class="el" href="class_vector.html">Vector</a> &amp;vecStart, const <a class="el" href="class_vector.html">Vector</a> &amp;vecEnd, int fNoMonsters, <a class="el" href="structedict__t.html">edict_t</a> *pentToSkip, <a class="el" href="struct_trace_result.html">TraceResult</a> *ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a trace between a starting and ending position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecStart</td><td>Start position. </td></tr>
    <tr><td class="paramname">vecEnd</td><td>End position. </td></tr>
    <tr><td class="paramname">fNoMonsters</td><td>Bit vector containing trace flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="eiface_8h.html#a98a5bd4a96b7775127ba28299f2820ea">TraceLineFlag</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pentToSkip</td><td><a class="el" href="namespace_entity.html">Entity</a> to ignore during the trace. </td></tr>
    <tr><td class="paramname">ptr</td><td><a class="el" href="struct_trace_result.html">TraceResult</a> instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17b3bbd95259e5c9da81164b7ad2de00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnTraceModel) (const <a class="el" href="class_vector.html">Vector</a> &amp;vecStart, const <a class="el" href="class_vector.html">Vector</a> &amp;vecEnd, int hullNumber, <a class="el" href="structedict__t.html">edict_t</a> *pEntity, <a class="el" href="struct_trace_result.html">TraceResult</a> *ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a trace between a starting and ending position. Similar to TraceHull, but will instead perform a trace in the given world hull using the given entity's model's hulls. For studio models this will use the model's hitboxes.</p>
<p>If the given entity's model is a studio model, uses its hitboxes. If it's a brush model, the brush model's hull for the given hull number is used (this may differ if custom brush hull sizes are in use). Otherwise, the entity bounds are converted into a hull.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecStart</td><td>Start position. </td></tr>
    <tr><td class="paramname">vecEnd</td><td>End position. </td></tr>
    <tr><td class="paramname">hullNumber</td><td><a class="el" href="namespace_hull.html">Hull</a> to use. </td></tr>
    <tr><td class="paramname">pEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> whose hull will be used. </td></tr>
    <tr><td class="paramname">ptr</td><td><a class="el" href="struct_trace_result.html">TraceResult</a> instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04f5326711aa17c8f734288e8f86bd3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnTraceMonsterHull) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity, const <a class="el" href="class_vector.html">Vector</a> &amp;vecStart, const <a class="el" href="class_vector.html">Vector</a> &amp;vecEnd, int fNoMonsters, <a class="el" href="structedict__t.html">edict_t</a> *pentToSkip, <a class="el" href="struct_trace_result.html">TraceResult</a> *ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a trace between a starting and ending position, using the given entity's mins and maxs. This can be any entity, not just monsters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> whose hull will be used. </td></tr>
    <tr><td class="paramname">vecStart</td><td>Start position. </td></tr>
    <tr><td class="paramname">vecEnd</td><td>End position. </td></tr>
    <tr><td class="paramname">fNoMonsters</td><td>Bit vector containing trace flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="eiface_8h.html#a98a5bd4a96b7775127ba28299f2820ea">TraceLineFlag</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pentToSkip</td><td><a class="el" href="namespace_entity.html">Entity</a> to ignore during the trace. </td></tr>
    <tr><td class="paramname">ptr</td><td><a class="el" href="struct_trace_result.html">TraceResult</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the trace was entirely in a solid object, or if it hit something. </dd></dl>

</div>
</div>
<a class="anchor" id="afbfca298232ae79dedc22227d801a32c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnTraceSphere) (const <a class="el" href="class_vector.html">Vector</a> &amp;vecStart, const <a class="el" href="class_vector.html">Vector</a> &amp;vecEnd, int fNoMonsters, float radius, <a class="el" href="structedict__t.html">edict_t</a> *pentToSkip, <a class="el" href="struct_trace_result.html">TraceResult</a> *ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Not implemented. Triggers a sys error. </p>

</div>
</div>
<a class="anchor" id="a4eed3bc999fd9098fbda7d5e72e42299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structtexture__t.html">texture_t</a>*(* enginefuncs_t::pfnTraceTexture) (<a class="el" href="structedict__t.html">edict_t</a> *pTextureEntity, const <a class="el" href="class_vector.html">Vector</a> &amp;vecStart, const <a class="el" href="class_vector.html">Vector</a> &amp;vecEnd)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to get texture info. The given entity must have a brush model set. If the traceline intersects the model, the texture of the surface it intersected is returned. Otherwise, returns null.</p>
<p>Was defined to return a const char*. However, the engine actually returns texture_t*, which works because <a class="el" href="structtexture__t.html#adc5a07a80bcaf2979e933bfbe6f469d8">texture_t::name</a> is the first element, so it's identical. <a class="el" href="structtexture__t.html">texture_t</a>'s layout differs between software and hardware mode, so avoid accessing its members.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTextureEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> whose texture is to be retrieved. </td></tr>
    <tr><td class="paramname">vecStart</td><td>Start position. </td></tr>
    <tr><td class="paramname">vecEnd</td><td>End position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Texture instance, or null if no texture could be found. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b99988b13711ea32d0bf4ddc4ce6c93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnTraceToss) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity, <a class="el" href="structedict__t.html">edict_t</a> *pentToIgnore, <a class="el" href="struct_trace_result.html">TraceResult</a> *ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Traces a toss. This simulates tossing the entity using its current origin, velocity, angular velocity, angles and gravity. Note that this does not use the same code as MOVETYPE_TOSS, and may return different results. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> to toss. </td></tr>
    <tr><td class="paramname">pentToIgnore</td><td><a class="el" href="namespace_entity.html">Entity</a> to ignore during the trace. </td></tr>
    <tr><td class="paramname">ptr</td><td><a class="el" href="struct_trace_result.html">TraceResult</a> instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fe3e6038bb37b2ed44e8ccf8286c305"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnVecToAngles) (const <a class="el" href="class_vector.html">Vector</a> &amp;vecIn, <a class="el" href="class_vector.html">Vector</a> &amp;vecOut)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a direction vector to angles. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecIn</td><td>Direction vector. </td></tr>
    <tr><td class="paramname">vecOut</td><td>Angles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92a3b1b2a4a103616d95c62b5c1e322b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float(* enginefuncs_t::pfnVecToYaw) (const <a class="el" href="class_vector.html">Vector</a> &amp;vecVector)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a direction vector to a yaw angle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecVector</td><td>Direction vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Yaw angle. </dd></dl>

</div>
</div>
<a class="anchor" id="a974aa27586a73844436c62dbd62d989b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cmdlib_8h.html#a110846a9664bbd925f955266e60e9136">qboolean</a>(* enginefuncs_t::pfnVoice_GetClientListening) (int iReceiver, int iSender)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets whether the given receiver can hear the given sender. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iReceiver</td><td>Receiver. This is an entity index. </td></tr>
    <tr><td class="paramname">iSender</td><td>Sender. This is an entity index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the given receiver can hear the given sender. </dd></dl>

</div>
</div>
<a class="anchor" id="a184b9c345e6450943518f25396626508"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cmdlib_8h.html#a110846a9664bbd925f955266e60e9136">qboolean</a>(* enginefuncs_t::pfnVoice_SetClientListening) (int iReceiver, int iSender, <a class="el" href="cmdlib_8h.html#a110846a9664bbd925f955266e60e9136">qboolean</a> bListen)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets whether the given receiver can hear the given sender. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iReceiver</td><td>Receiver. This is an entity index. </td></tr>
    <tr><td class="paramname">iSender</td><td>Sender. This is an entity index. </td></tr>
    <tr><td class="paramname">bListen</td><td>Whether the given receiver can hear the given sender. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the setting was changed. </dd></dl>

</div>
</div>
<a class="anchor" id="a0cbb55e6ec08db6ccda8419143722b1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* enginefuncs_t::pfnWalkMove) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity, float yaw, float dist, int iMode)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes the entity walk.</p>
<p>The entity must be capable of flying (FL_FLY) or swimming (FL_SWIM), or be on the ground (FL_ONGROUND). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> to move. </td></tr>
    <tr><td class="paramname">yaw</td><td>Yaw distance. This is the entity's current movement direction in the XY plane. </td></tr>
    <tr><td class="paramname">Distance</td><td>to move, in units. </td></tr>
    <tr><td class="paramname">iMove</td><td>Movement type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="const_8h.html#a2802388fdbee8d4273000474102ce2dd">WalkMove</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the move succeeded (no obstacles in the way), 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d327e34a3d381636b1ad06b0b23afde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnWriteAngle) (float flValue)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a single angle value.</p>
<p>If no message had been started, triggers a sys error. </p>

</div>
</div>
<a class="anchor" id="aedd9113be2930ca234a5655f2766f888"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnWriteByte) (int iValue)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a single unsigned byte.</p>
<p>If no message had been started, triggers a sys error. </p>

</div>
</div>
<a class="anchor" id="ab6ece4cfb1d87e6e766a2352073c4ea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnWriteChar) (int iValue)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a single character.</p>
<p>If no message had been started, triggers a sys error. </p>

</div>
</div>
<a class="anchor" id="a017c7ace8a8e1828faa347698fab2da8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnWriteCoord) (float flValue)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a single coordinate value.</p>
<p>If no message had been started, triggers a sys error. </p>

</div>
</div>
<a class="anchor" id="af07d049d353343287de93159095b5456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnWriteEntity) (int iValue)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a single entity index.</p>
<p>If no message had been started, triggers a sys error. </p>

</div>
</div>
<a class="anchor" id="add3e03347d50d3aa205115dad24f7989"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnWriteLong) (int iValue)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a single unsigned int.</p>
<p>If no message had been started, triggers a sys error. </p>

</div>
</div>
<a class="anchor" id="ab2ee0f34c619b710e1099f09e8bb20ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnWriteShort) (int iValue)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a single unsigned short.</p>
<p>If no message had been started, triggers a sys error. </p>

</div>
</div>
<a class="anchor" id="acf04813261332735f1b8a7e872038308"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::pfnWriteString) (const char *pszString)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a single null terminated string.</p>
<p>If no message had been started, triggers a sys error. </p>

</div>
</div>
<a class="anchor" id="a7b1fccd1c86a2136c61387f4855b86a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::ProcessTutorMessageDecayBuffer) (int *pBuffer, int bufferLength)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Processes the tutor message decay buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuffer</td><td>Buffer. </td></tr>
    <tr><td class="paramname">bufferLength</td><td>Size of the buffer, in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14067cd5bf89168e73925c4141a738f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* enginefuncs_t::ResetTutorMessageDecayData) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets tutor message decay data. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>engine/<a class="el" href="eiface_8h_source.html">eiface.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structenginefuncs__t.html">enginefuncs_t</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
