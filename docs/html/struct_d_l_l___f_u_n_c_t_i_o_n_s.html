<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Half-Life Enhanced: DLL_FUNCTIONS Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Half-Life Enhanced
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Enhanced Half-Life SDK</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('struct_d_l_l___f_u_n_c_t_i_o_n_s.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct_d_l_l___f_u_n_c_t_i_o_n_s-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DLL_FUNCTIONS Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="eiface_8h_source.html">eiface.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a584685a015e898e7dc535c2fb2a749b8"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a584685a015e898e7dc535c2fb2a749b8">pfnGameInit</a> )(void)</td></tr>
<tr class="separator:a584685a015e898e7dc535c2fb2a749b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac126c13b861a3eebe1e78c5b8d0c06e4"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#ac126c13b861a3eebe1e78c5b8d0c06e4">pfnSpawn</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEnt)</td></tr>
<tr class="separator:ac126c13b861a3eebe1e78c5b8d0c06e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a7fb37893394dca296b6052ed7a9a5"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a94a7fb37893394dca296b6052ed7a9a5">pfnThink</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEnt)</td></tr>
<tr class="separator:a94a7fb37893394dca296b6052ed7a9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c828f92a56f41037e3e54b73380d55f"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a1c828f92a56f41037e3e54b73380d55f">pfnUse</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntUsed, <a class="el" href="structedict__t.html">edict_t</a> *pEntOther)</td></tr>
<tr class="separator:a1c828f92a56f41037e3e54b73380d55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdaacb882674b044fd6b4d1689e15436"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#abdaacb882674b044fd6b4d1689e15436">pfnTouch</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntTouched, <a class="el" href="structedict__t.html">edict_t</a> *pEntOther)</td></tr>
<tr class="separator:abdaacb882674b044fd6b4d1689e15436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01250165e7e76107e2607761ead766c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#af01250165e7e76107e2607761ead766c">pfnBlocked</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntBlocked, <a class="el" href="structedict__t.html">edict_t</a> *pEntOther)</td></tr>
<tr class="separator:af01250165e7e76107e2607761ead766c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed1943884805986227cdf25a8e99523"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#aeed1943884805986227cdf25a8e99523">pfnKeyValue</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntKeyvalue, <a class="el" href="struct_key_value_data.html">KeyValueData</a> *pkvd)</td></tr>
<tr class="separator:aeed1943884805986227cdf25a8e99523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27505ade300c6d59a5f4335cf941cee2"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a27505ade300c6d59a5f4335cf941cee2">pfnSave</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEnt, <a class="el" href="struct_s_a_v_e_r_e_s_t_o_r_e_d_a_t_a.html">SAVERESTOREDATA</a> *pSaveData)</td></tr>
<tr class="separator:a27505ade300c6d59a5f4335cf941cee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85394accc564ceda99734518bf391d5a"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a85394accc564ceda99734518bf391d5a">pfnRestore</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEnt, <a class="el" href="struct_s_a_v_e_r_e_s_t_o_r_e_d_a_t_a.html">SAVERESTOREDATA</a> *pSaveData, int globalEntity)</td></tr>
<tr class="separator:a85394accc564ceda99734518bf391d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49a7098bf1b4795a4a1abe06f9b1cc2"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#ab49a7098bf1b4795a4a1abe06f9b1cc2">pfnSetAbsBox</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEnt)</td></tr>
<tr class="separator:ab49a7098bf1b4795a4a1abe06f9b1cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72d05c2b0ed83150d6a363b322d7119"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#ab72d05c2b0ed83150d6a363b322d7119">pfnSaveWriteFields</a> )(<a class="el" href="struct_s_a_v_e_r_e_s_t_o_r_e_d_a_t_a.html">SAVERESTOREDATA</a> *pSaveData, const char *pszName, void *pBaseData, <a class="el" href="structengine_1_1_t_y_p_e_d_e_s_c_r_i_p_t_i_o_n.html">engine::TYPEDESCRIPTION</a> *pFields, int fieldCount)</td></tr>
<tr class="separator:ab72d05c2b0ed83150d6a363b322d7119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b7f124ea53c91f6e633b51eb5d39ca"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#ac0b7f124ea53c91f6e633b51eb5d39ca">pfnSaveReadFields</a> )(<a class="el" href="struct_s_a_v_e_r_e_s_t_o_r_e_d_a_t_a.html">SAVERESTOREDATA</a> *pSaveData, const char *pszName, void *pBaseData, <a class="el" href="structengine_1_1_t_y_p_e_d_e_s_c_r_i_p_t_i_o_n.html">engine::TYPEDESCRIPTION</a> *pFields, int fieldCount)</td></tr>
<tr class="separator:ac0b7f124ea53c91f6e633b51eb5d39ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2198626c095b061ace237c6496bd3b77"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a2198626c095b061ace237c6496bd3b77">pfnSaveGlobalState</a> )(<a class="el" href="struct_s_a_v_e_r_e_s_t_o_r_e_d_a_t_a.html">SAVERESTOREDATA</a> *pSaveData)</td></tr>
<tr class="separator:a2198626c095b061ace237c6496bd3b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb4a1b0dd7bc141690a3e2ccdaec436"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a8bb4a1b0dd7bc141690a3e2ccdaec436">pfnRestoreGlobalState</a> )(<a class="el" href="struct_s_a_v_e_r_e_s_t_o_r_e_d_a_t_a.html">SAVERESTOREDATA</a> *pSaveData)</td></tr>
<tr class="separator:a8bb4a1b0dd7bc141690a3e2ccdaec436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55307d1e20d5cd686811d4bb9f47420f"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a55307d1e20d5cd686811d4bb9f47420f">pfnResetGlobalState</a> )(void)</td></tr>
<tr class="separator:a55307d1e20d5cd686811d4bb9f47420f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894de7eca7a0e902f3ee77ccc319ce3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cmdlib_8h.html#a110846a9664bbd925f955266e60e9136">qboolean</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a894de7eca7a0e902f3ee77ccc319ce3a">pfnClientConnect</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity, const char *pszName, const char *pszAddress, char szRejectReason[<a class="el" href="eiface_8h.html#afd747f1e4e917cade5441b0ff9cde454">CCONNECT_REJECT_REASON_SIZE</a>])</td></tr>
<tr class="separator:a894de7eca7a0e902f3ee77ccc319ce3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85b51c063f81e56c32096a2446aa26b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#ab85b51c063f81e56c32096a2446aa26b">pfnClientDisconnect</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td></tr>
<tr class="separator:ab85b51c063f81e56c32096a2446aa26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84602e6489cd41c8f36d86247da84148"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a84602e6489cd41c8f36d86247da84148">pfnClientKill</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td></tr>
<tr class="separator:a84602e6489cd41c8f36d86247da84148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ef8b8359d4169e4de029e71dc36eea"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a30ef8b8359d4169e4de029e71dc36eea">pfnClientPutInServer</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td></tr>
<tr class="separator:a30ef8b8359d4169e4de029e71dc36eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa987e5d006e763c20d257c66c03d9a6f"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#aa987e5d006e763c20d257c66c03d9a6f">pfnClientCommand</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td></tr>
<tr class="separator:aa987e5d006e763c20d257c66c03d9a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c787155d780fe579252100fa8edd270"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a3c787155d780fe579252100fa8edd270">pfnClientUserInfoChanged</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity, char *pszInfoBuffer)</td></tr>
<tr class="separator:a3c787155d780fe579252100fa8edd270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17810e0b2078fb03b6256fa4a5dd33e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#ab17810e0b2078fb03b6256fa4a5dd33e">pfnServerActivate</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEdictList, int edictCount, int clientMax)</td></tr>
<tr class="separator:ab17810e0b2078fb03b6256fa4a5dd33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade253fb9d981d9769c458a0485b7c0c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#aade253fb9d981d9769c458a0485b7c0c">pfnServerDeactivate</a> )(void)</td></tr>
<tr class="separator:aade253fb9d981d9769c458a0485b7c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42572d3ac28502cb7206eaedfa67d360"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a42572d3ac28502cb7206eaedfa67d360">pfnPlayerPreThink</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td></tr>
<tr class="separator:a42572d3ac28502cb7206eaedfa67d360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7d4f390164fe7ae61323a44ae79280"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a1b7d4f390164fe7ae61323a44ae79280">pfnPlayerPostThink</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td></tr>
<tr class="separator:a1b7d4f390164fe7ae61323a44ae79280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8457dcd0bd1cb3f21e6cfddfd86d2f6"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#ae8457dcd0bd1cb3f21e6cfddfd86d2f6">pfnStartFrame</a> )(void)</td></tr>
<tr class="separator:ae8457dcd0bd1cb3f21e6cfddfd86d2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4982990b24664cff2bb6ff77d89d36"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a5f4982990b24664cff2bb6ff77d89d36">pfnParmsNewLevel</a> )(void)</td></tr>
<tr class="separator:a5f4982990b24664cff2bb6ff77d89d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ecc2506d274d8287b3ad1a7a9f8d53c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a6ecc2506d274d8287b3ad1a7a9f8d53c">pfnParmsChangeLevel</a> )(void)</td></tr>
<tr class="separator:a6ecc2506d274d8287b3ad1a7a9f8d53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c1365bbf171b397dba2a1aab366957"><td class="memItemLeft" align="right" valign="top">const char *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a23c1365bbf171b397dba2a1aab366957">pfnGetGameDescription</a> )(void)</td></tr>
<tr class="separator:a23c1365bbf171b397dba2a1aab366957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9822e562422eb13052bb2acb78b6421f"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a9822e562422eb13052bb2acb78b6421f">pfnPlayerCustomization</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity, <a class="el" href="structcustomization__t.html">customization_t</a> *pCustom)</td></tr>
<tr class="separator:a9822e562422eb13052bb2acb78b6421f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134740fc5303103620fb8505696378a1"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a134740fc5303103620fb8505696378a1">pfnSpectatorConnect</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td></tr>
<tr class="separator:a134740fc5303103620fb8505696378a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fdb409f2e4b035d4fb1e70422051fe"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#af9fdb409f2e4b035d4fb1e70422051fe">pfnSpectatorDisconnect</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td></tr>
<tr class="separator:af9fdb409f2e4b035d4fb1e70422051fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62dd8106bec6cdf940d15c26dad1327"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#aa62dd8106bec6cdf940d15c26dad1327">pfnSpectatorThink</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td></tr>
<tr class="separator:aa62dd8106bec6cdf940d15c26dad1327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe5f60070b59879cf2fc32ba9cec134"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#acfe5f60070b59879cf2fc32ba9cec134">pfnSys_Error</a> )(const char *error_string)</td></tr>
<tr class="separator:acfe5f60070b59879cf2fc32ba9cec134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e7fd4231b4c89bf5f288479a422154"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a36e7fd4231b4c89bf5f288479a422154">pfnPM_Move</a> )(<a class="el" href="structplayermove__t.html">playermove_t</a> *pPMove, <a class="el" href="cmdlib_8h.html#a110846a9664bbd925f955266e60e9136">qboolean</a> server)</td></tr>
<tr class="separator:a36e7fd4231b4c89bf5f288479a422154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cb4ba6c2fb2385e09eadc95dd0cd2d"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#aa1cb4ba6c2fb2385e09eadc95dd0cd2d">pfnPM_Init</a> )(<a class="el" href="structplayermove__t.html">playermove_t</a> *pPMove)</td></tr>
<tr class="separator:aa1cb4ba6c2fb2385e09eadc95dd0cd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc10b6c672a2aefab072961ff58f781"><td class="memItemLeft" align="right" valign="top">char(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#aecc10b6c672a2aefab072961ff58f781">pfnPM_FindTextureType</a> )(const char *pszName)</td></tr>
<tr class="separator:aecc10b6c672a2aefab072961ff58f781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d3955bb80567c9ed9694d9b4ec9fac"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#aa7d3955bb80567c9ed9694d9b4ec9fac">pfnSetupVisibility</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pViewEntity, <a class="el" href="structedict__t.html">edict_t</a> *pClient, unsigned char **pvs, unsigned char **pas)</td></tr>
<tr class="separator:aa7d3955bb80567c9ed9694d9b4ec9fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9baea41941a3cf5a639a19d8eeb4a3f0"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a9baea41941a3cf5a639a19d8eeb4a3f0">pfnUpdateClientData</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pClient, int sendweapons, <a class="el" href="structclientdata__t.html">clientdata_t</a> *cd)</td></tr>
<tr class="separator:a9baea41941a3cf5a639a19d8eeb4a3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec61c1ebdf1b0b85a032e91862866515"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#aec61c1ebdf1b0b85a032e91862866515">pfnAddToFullPack</a> )(<a class="el" href="structentity__state__t.html">entity_state_t</a> *state, int entIndex, <a class="el" href="structedict__t.html">edict_t</a> *pEnt, <a class="el" href="structedict__t.html">edict_t</a> *pHost, int hostflags, int player, unsigned char *pSet)</td></tr>
<tr class="separator:aec61c1ebdf1b0b85a032e91862866515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3031af523829286c7e43af979a8859f2"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a3031af523829286c7e43af979a8859f2">pfnCreateBaseline</a> )(int player, int eindex, <a class="el" href="structentity__state__t.html">entity_state_t</a> *baseline, <a class="el" href="structedict__t.html">edict_t</a> *entity, int playermodelindex, const <a class="el" href="class_vector.html">Vector</a> player_mins[<a class="el" href="namespace_hull.html#a781b48dcd50dd417593ccbe8cc5c6292a3ad57063b7e13c2c6cd5fdba7190d5a8">Hull::COUNT</a>], const <a class="el" href="class_vector.html">Vector</a> player_maxs[<a class="el" href="namespace_hull.html#a781b48dcd50dd417593ccbe8cc5c6292a3ad57063b7e13c2c6cd5fdba7190d5a8">Hull::COUNT</a>])</td></tr>
<tr class="separator:a3031af523829286c7e43af979a8859f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6762c4d7926f9ddb0349e84297a35554"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a6762c4d7926f9ddb0349e84297a35554">pfnRegisterEncoders</a> )(void)</td></tr>
<tr class="separator:a6762c4d7926f9ddb0349e84297a35554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ec8ff43c847880290267ccd0829afe"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a58ec8ff43c847880290267ccd0829afe">pfnGetWeaponData</a> )(<a class="el" href="structedict__t.html">edict_t</a> *pPlayer, <a class="el" href="structweapon__data__t.html">weapon_data_t</a> *pInfo)</td></tr>
<tr class="separator:a58ec8ff43c847880290267ccd0829afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337839d7652493d3c0508a2088a405f3"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a337839d7652493d3c0508a2088a405f3">pfnCmdStart</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pPlayer, const <a class="el" href="structusercmd__t.html">usercmd_t</a> *cmd, unsigned int random_seed)</td></tr>
<tr class="separator:a337839d7652493d3c0508a2088a405f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aa9aad39c5f1dfddf50018a9b21b05"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a21aa9aad39c5f1dfddf50018a9b21b05">pfnCmdEnd</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *pPlayer)</td></tr>
<tr class="separator:a21aa9aad39c5f1dfddf50018a9b21b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab376d958d8d08c5d6fc604906e34370c"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#ab376d958d8d08c5d6fc604906e34370c">pfnConnectionlessPacket</a> )(const <a class="el" href="structnetadr__t.html">netadr_t</a> *net_from, const char *pszArgs, char *response_buffer, int *response_buffer_size)</td></tr>
<tr class="separator:ab376d958d8d08c5d6fc604906e34370c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b13917927d4548bde6b191233e4695"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#af1b13917927d4548bde6b191233e4695">pfnGetHullBounds</a> )(int hullnumber, <a class="el" href="class_vector.html">Vector</a> &amp;mins, <a class="el" href="class_vector.html">Vector</a> &amp;maxs)</td></tr>
<tr class="separator:af1b13917927d4548bde6b191233e4695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad8b333af518e2dd70fe829058e9da4"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#acad8b333af518e2dd70fe829058e9da4">pfnCreateInstancedBaselines</a> )(void)</td></tr>
<tr class="separator:acad8b333af518e2dd70fe829058e9da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c3c513d1429607b13687bdc86f11a9"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a04c3c513d1429607b13687bdc86f11a9">pfnInconsistentFile</a> )(const <a class="el" href="structedict__t.html">edict_t</a> *player, const char *pszFileName, char *disconnect_message)</td></tr>
<tr class="separator:a04c3c513d1429607b13687bdc86f11a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e1a86396056d14562503711f8d9e24"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a51e1a86396056d14562503711f8d9e24">pfnAllowLagCompensation</a> )(void)</td></tr>
<tr class="separator:a51e1a86396056d14562503711f8d9e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Server library interface to the engine. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aec61c1ebdf1b0b85a032e91862866515"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* DLL_FUNCTIONS::pfnAddToFullPack) (<a class="el" href="structentity__state__t.html">entity_state_t</a> *state, int entIndex, <a class="el" href="structedict__t.html">edict_t</a> *pEnt, <a class="el" href="structedict__t.html">edict_t</a> *pHost, int hostflags, int player, unsigned char *pSet)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to determine whether the given entity should be added to the given client's list of visible entities. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pState</td><td>state <a class="el" href="namespace_entity.html">Entity</a> state data for the entity that is being added. </td></tr>
    <tr><td class="paramname">entIndex</td><td>Index of the entity being considered for addition. </td></tr>
    <tr><td class="paramname">pEnt</td><td><a class="el" href="namespace_entity.html">Entity</a> being considered for addition. </td></tr>
    <tr><td class="paramname">pHost</td><td>Client currently being processed. </td></tr>
    <tr><td class="paramname">hostflags</td><td>Host flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="client_8h.html#a5e735a1bff4b25067a28fa0e47304d3b">HostFlag</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">player</td><td>true if the entity being added is a player, false otherwise. </td></tr>
    <tr><td class="paramname">pSet</td><td>The PVS provided by pfnSetupVisibility </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#aa7d3955bb80567c9ed9694d9b4ec9fac">pfnSetupVisibility</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a51e1a86396056d14562503711f8d9e24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* DLL_FUNCTIONS::pfnAllowLagCompensation) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The game .dll should return 1 if lag compensation should be allowed ( could also just set the sv_unlag cvar. Most games right now should return 0, until client-side weapon prediction code is written and tested for them. </p>

</div>
</div>
<a class="anchor" id="af01250165e7e76107e2607761ead766c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnBlocked) (<a class="el" href="structedict__t.html">edict_t</a> *pEntBlocked, <a class="el" href="structedict__t.html">edict_t</a> *pEntOther)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to run pEntBlocked's Blocked function with pEntOther as the other entity. </p>

</div>
</div>
<a class="anchor" id="aa987e5d006e763c20d257c66c03d9a6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnClientCommand) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine when it has received a command from the given client. Command arguments can be retrieved using <a class="el" href="structenginefuncs__t.html#a3dd2ae76c7bda444b69be84818d3feaf">enginefuncs_t::pfnCmd_Args</a>, <a class="el" href="structenginefuncs__t.html#a20c467675fbc85972742de722f5ce875">enginefuncs_t::pfnCmd_Argv</a>, <a class="el" href="structenginefuncs__t.html#a7d18d17c26875c41a929f9e2ad6b237e">enginefuncs_t::pfnCmd_Argc</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structenginefuncs__t.html#a3dd2ae76c7bda444b69be84818d3feaf">enginefuncs_t::pfnCmd_Args</a> </dd>
<dd>
<a class="el" href="structenginefuncs__t.html#a20c467675fbc85972742de722f5ce875">enginefuncs_t::pfnCmd_Argv</a> </dd>
<dd>
<a class="el" href="structenginefuncs__t.html#a7d18d17c26875c41a929f9e2ad6b237e">enginefuncs_t::pfnCmd_Argc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a894de7eca7a0e902f3ee77ccc319ce3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cmdlib_8h.html#a110846a9664bbd925f955266e60e9136">qboolean</a>(* DLL_FUNCTIONS::pfnClientConnect) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity, const char *pszName, const char *pszAddress, char szRejectReason[<a class="el" href="eiface_8h.html#afd747f1e4e917cade5441b0ff9cde454">CCONNECT_REJECT_REASON_SIZE</a>])</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine when a client connects. Returning false rejects the client's connection. Setting szRejectReason presents that to the client. Note: network messages cannot be sent at this time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEntity</td><td><a class="el" href="namespace_entity.html">Entity</a> that represents this client. </td></tr>
    <tr><td class="paramname">pszName</td><td>Netname of the player. </td></tr>
    <tr><td class="paramname">pszAddress</td><td>IP address of the client. </td></tr>
    <tr><td class="paramname">szRejectReason</td><td>Reason why the client was rejected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the client should be allowed to connect, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab85b51c063f81e56c32096a2446aa26b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnClientDisconnect) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when a client disconnects. This will not be called if the client connection was rejected in pfnClientConnect. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html#a894de7eca7a0e902f3ee77ccc319ce3a">pfnClientConnect</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a84602e6489cd41c8f36d86247da84148"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnClientKill) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine when the player has issued a "kill" command. Only if the player's health is larger than 0. </p>

</div>
</div>
<a class="anchor" id="a30ef8b8359d4169e4de029e71dc36eea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnClientPutInServer) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine when the client has finished connecting. This is where the player should be spawned and put into the world, or given a spectator position to view from. Note: network messages cannot be sent at this time. </p>

</div>
</div>
<a class="anchor" id="a3c787155d780fe579252100fa8edd270"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnClientUserInfoChanged) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity, char *pszInfoBuffer)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine whenever the client's user info string changes. This includes the player's model. </p>

</div>
</div>
<a class="anchor" id="a21aa9aad39c5f1dfddf50018a9b21b05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnCmdEnd) (const <a class="el" href="structedict__t.html">edict_t</a> *pPlayer)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine when a user command has finished processing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPlayer</td><td>Player. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a337839d7652493d3c0508a2088a405f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnCmdStart) (const <a class="el" href="structedict__t.html">edict_t</a> *pPlayer, const <a class="el" href="structusercmd__t.html">usercmd_t</a> *cmd, unsigned int random_seed)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine when a user command has been received and is about to begin processing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPlayer</td><td>Player. </td></tr>
    <tr><td class="paramname">cmd</td><td>Command being executed. </td></tr>
    <tr><td class="paramname">random_seed</td><td>The player's current random seed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab376d958d8d08c5d6fc604906e34370c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* DLL_FUNCTIONS::pfnConnectionlessPacket) (const <a class="el" href="structnetadr__t.html">netadr_t</a> *net_from, const char *pszArgs, char *response_buffer, int *response_buffer_size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return 1 if the packet is valid. Set response_buffer_size if you want to send a response packet. Incoming, it holds the max size of the response_buffer, so you must zero it out if you choose not to respond.</p>
<p>This can be used to handle commands akin to rcon. The remote server console can send commands that end up here. Note that anyone can send messages that reach this point, not just rcon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">net_from</td><td>IP address of the sender of this packet. </td></tr>
    <tr><td class="paramname">pszArgs</td><td>Arguments provided by the sender. </td></tr>
    <tr><td class="paramname">response_buffer</td><td>Buffer that a response can be written into. </td></tr>
    <tr><td class="paramname">response_buffer_size</td><td>Size of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the packet has been handled, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3031af523829286c7e43af979a8859f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnCreateBaseline) (int player, int eindex, <a class="el" href="structentity__state__t.html">entity_state_t</a> *baseline, <a class="el" href="structedict__t.html">edict_t</a> *entity, int playermodelindex, const <a class="el" href="class_vector.html">Vector</a> player_mins[<a class="el" href="namespace_hull.html#a781b48dcd50dd417593ccbe8cc5c6292a3ad57063b7e13c2c6cd5fdba7190d5a8">Hull::COUNT</a>], const <a class="el" href="class_vector.html">Vector</a> player_maxs[<a class="el" href="namespace_hull.html#a781b48dcd50dd417593ccbe8cc5c6292a3ad57063b7e13c2c6cd5fdba7190d5a8">Hull::COUNT</a>])</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to create a baseline for the given entity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">player</td><td>Boolean indicating whether this is a player. </td></tr>
    <tr><td class="paramname">eindex</td><td><a class="el" href="namespace_entity.html">Entity</a> index of this entity. </td></tr>
    <tr><td class="paramname">baseline</td><td>Baseline to fill. </td></tr>
    <tr><td class="paramname">entity</td><td><a class="el" href="namespace_entity.html">Entity</a> to make the baseline for. </td></tr>
    <tr><td class="paramname">playermodelindex</td><td>Index of the model "models/player.mdl". </td></tr>
    <tr><td class="paramname">player_mins</td><td>Array of the player minimum bounds for each hull. </td></tr>
    <tr><td class="paramname">player_maxs</td><td>Array of the player maximum bounds for each hull. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acad8b333af518e2dd70fe829058e9da4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnCreateInstancedBaselines) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create baselines for certain "unplaced" items. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structenginefuncs__t.html#a1da4235cde80c7b7f810d425aa126d26">enginefuncs_t::pfnCreateInstancedBaseline</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a584685a015e898e7dc535c2fb2a749b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnGameInit) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when the game loads this DLL. </p>

</div>
</div>
<a class="anchor" id="a23c1365bbf171b397dba2a1aab366957"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char*(* DLL_FUNCTIONS::pfnGetGameDescription) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af1b13917927d4548bde6b191233e4695"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* DLL_FUNCTIONS::pfnGetHullBounds) (int hullnumber, <a class="el" href="class_vector.html">Vector</a> &amp;mins, <a class="el" href="class_vector.html">Vector</a> &amp;maxs)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumerates player hulls. Returns 0 if the hull number doesn't exist, 1 otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hullnumber</td><td><a class="el" href="namespace_hull.html">Hull</a> to retrieve the bounds for. </td></tr>
    <tr><td class="paramname">mins</td><td>Minimum bounds. </td></tr>
    <tr><td class="paramname">maxs</td><td>Maximum bounds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the hull was successfully retrieved, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a58ec8ff43c847880290267ccd0829afe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* DLL_FUNCTIONS::pfnGetWeaponData) (<a class="el" href="structedict__t.html">edict_t</a> *pPlayer, <a class="el" href="structweapon__data__t.html">weapon_data_t</a> *pInfo)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to retrieve weapon data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPlayer</td><td>Player to retrieve weapon info from. </td></tr>
    <tr><td class="paramname">pInfo</td><td>Array of <a class="el" href="structweapon__data__t.html">weapon_data_t</a> that should receive the player's weapon data. Is an array of MAX_WEAPONS entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data was added, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a04c3c513d1429607b13687bdc86f11a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* DLL_FUNCTIONS::pfnInconsistentFile) (const <a class="el" href="structedict__t.html">edict_t</a> *player, const char *pszFileName, char *disconnect_message)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>One of the pfnForceUnmodified files failed the consistency check for the specified player Return 0 to allow the client to continue, 1 to force immediate disconnection ( with an optional disconnect message of up to 256 characters ) </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structenginefuncs__t.html#a5012e7fd0074a69b9153bed00d58b714">enginefuncs_t::pfnForceUnmodified</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aeed1943884805986227cdf25a8e99523"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnKeyValue) (<a class="el" href="structedict__t.html">edict_t</a> *pEntKeyvalue, <a class="el" href="struct_key_value_data.html">KeyValueData</a> *pkvd)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to run pEntKeyvalue's KeyValue function with pkvd as the keyvalue data. </p>

</div>
</div>
<a class="anchor" id="a6ecc2506d274d8287b3ad1a7a9f8d53c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnParmsChangeLevel) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine when a level is saved. Also called when a player has spawned after a saved game has been loaded. </p>

</div>
</div>
<a class="anchor" id="a5f4982990b24664cff2bb6ff77d89d36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnParmsNewLevel) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obsolete. </p>

</div>
</div>
<a class="anchor" id="a9822e562422eb13052bb2acb78b6421f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnPlayerCustomization) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity, <a class="el" href="structcustomization__t.html">customization_t</a> *pCustom)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notify dll about a player customization. </p>

</div>
</div>
<a class="anchor" id="a1b7d4f390164fe7ae61323a44ae79280"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnPlayerPostThink) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine after it runs physics. </p>

</div>
</div>
<a class="anchor" id="a42572d3ac28502cb7206eaedfa67d360"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnPlayerPreThink) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine before it runs physics. </p>

</div>
</div>
<a class="anchor" id="aecc10b6c672a2aefab072961ff58f781"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char(* DLL_FUNCTIONS::pfnPM_FindTextureType) (const char *pszName)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to find the texture type of a given texture. Never actually called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>Name of the texture to look up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Texture type. Should always return a valid value, even if no data is available for the given texture. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1cb4ba6c2fb2385e09eadc95dd0cd2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnPM_Init) (<a class="el" href="structplayermove__t.html">playermove_t</a> *pPMove)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to initialize the player physics data. </p>

</div>
</div>
<a class="anchor" id="a36e7fd4231b4c89bf5f288479a422154"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnPM_Move) (<a class="el" href="structplayermove__t.html">playermove_t</a> *pPMove, <a class="el" href="cmdlib_8h.html#a110846a9664bbd925f955266e60e9136">qboolean</a> server)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to run player physics. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPMove</td><td>Pointer to player movement data. </td></tr>
    <tr><td class="paramname">server</td><td>Whether this is the server or client physics code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6762c4d7926f9ddb0349e84297a35554"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnRegisterEncoders) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to allow the server to register delta encoders. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structenginefuncs__t.html#ac14cd05df97eeca2679979a329473cc6">enginefuncs_t::pfnDeltaAddEncoder</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a55307d1e20d5cd686811d4bb9f47420f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnResetGlobalState) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to reset global state. </p>

</div>
</div>
<a class="anchor" id="a85394accc564ceda99734518bf391d5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* DLL_FUNCTIONS::pfnRestore) (<a class="el" href="structedict__t.html">edict_t</a> *pEnt, <a class="el" href="struct_s_a_v_e_r_e_s_t_o_r_e_d_a_t_a.html">SAVERESTOREDATA</a> *pSaveData, int globalEntity)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to restore the given entity's state from the given save data block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">globalEntity</td><td>Boolean indicating whether this entity has a global name, or was transitioned from another map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8bb4a1b0dd7bc141690a3e2ccdaec436"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnRestoreGlobalState) (<a class="el" href="struct_s_a_v_e_r_e_s_t_o_r_e_d_a_t_a.html">SAVERESTOREDATA</a> *pSaveData)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to restore global state. </p>

</div>
</div>
<a class="anchor" id="a27505ade300c6d59a5f4335cf941cee2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnSave) (<a class="el" href="structedict__t.html">edict_t</a> *pEnt, <a class="el" href="struct_s_a_v_e_r_e_s_t_o_r_e_d_a_t_a.html">SAVERESTOREDATA</a> *pSaveData)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to save the given entity's state to the given save data block. </p>

</div>
</div>
<a class="anchor" id="a2198626c095b061ace237c6496bd3b77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnSaveGlobalState) (<a class="el" href="struct_s_a_v_e_r_e_s_t_o_r_e_d_a_t_a.html">SAVERESTOREDATA</a> *pSaveData)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to save global state. </p>

</div>
</div>
<a class="anchor" id="ac0b7f124ea53c91f6e633b51eb5d39ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnSaveReadFields) (<a class="el" href="struct_s_a_v_e_r_e_s_t_o_r_e_d_a_t_a.html">SAVERESTOREDATA</a> *pSaveData, const char *pszName, void *pBaseData, <a class="el" href="structengine_1_1_t_y_p_e_d_e_s_c_r_i_p_t_i_o_n.html">engine::TYPEDESCRIPTION</a> *pFields, int fieldCount)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to restore a named block of data from the given save data block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSaveData</td><td>Block to restore data from. </td></tr>
    <tr><td class="paramname">pszName</td><td>Name of the data block. </td></tr>
    <tr><td class="paramname">pBaseData</td><td>Pointer to the object containing the data. </td></tr>
    <tr><td class="paramname">pFields</td><td>List of type descriptions describing the object's data. </td></tr>
    <tr><td class="paramname">fieldCount</td><td>Number of type descriptions in pFields. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab72d05c2b0ed83150d6a363b322d7119"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnSaveWriteFields) (<a class="el" href="struct_s_a_v_e_r_e_s_t_o_r_e_d_a_t_a.html">SAVERESTOREDATA</a> *pSaveData, const char *pszName, void *pBaseData, <a class="el" href="structengine_1_1_t_y_p_e_d_e_s_c_r_i_p_t_i_o_n.html">engine::TYPEDESCRIPTION</a> *pFields, int fieldCount)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to save a named block of data to the given save data block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSaveData</td><td>Block to save data to. </td></tr>
    <tr><td class="paramname">pszName</td><td>Name of the data block. </td></tr>
    <tr><td class="paramname">pBaseData</td><td>Pointer to the object containing the data. </td></tr>
    <tr><td class="paramname">pFields</td><td>List of type descriptions describing the object's data. </td></tr>
    <tr><td class="paramname">fieldCount</td><td>Number of type descriptions in pFields. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab17810e0b2078fb03b6256fa4a5dd33e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnServerActivate) (<a class="el" href="structedict__t.html">edict_t</a> *pEdictList, int edictCount, int clientMax)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when the engine has finished spawning the map. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEdictList</td><td>Pointer to the list of edicts. </td></tr>
    <tr><td class="paramname">edictCount</td><td>Number of valid edicts. </td></tr>
    <tr><td class="paramname">clientMax</td><td>Maximum number of players that can connect to this server. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aade253fb9d981d9769c458a0485b7c0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnServerDeactivate) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when the map has ended. This happens before entities are destroyed. </p>

</div>
</div>
<a class="anchor" id="ab49a7098bf1b4795a4a1abe06f9b1cc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnSetAbsBox) (<a class="el" href="structedict__t.html">edict_t</a> *pEnt)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to set the given entity's absolute bounding box. </p>

</div>
</div>
<a class="anchor" id="aa7d3955bb80567c9ed9694d9b4ec9fac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnSetupVisibility) (<a class="el" href="structedict__t.html">edict_t</a> *pViewEntity, <a class="el" href="structedict__t.html">edict_t</a> *pClient, unsigned char **pvs, unsigned char **pas)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set up visibility for the given client. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pViewEntity</td><td>The client's view entity. This is the entity whose origin and view offset should be used as the client's view position. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pClient</td><td>The client. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvs</td><td>Pointer to Potentially Visible Set to use. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pas</td><td>Pointer to Potentially Audible Set to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac126c13b861a3eebe1e78c5b8d0c06e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* DLL_FUNCTIONS::pfnSpawn) (<a class="el" href="structedict__t.html">edict_t</a> *pEnt)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to spawn an entity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEnt</td><td><a class="el" href="namespace_entity.html">Entity</a> to spawn. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the entity was successfully spawned, or -1 if it should be removed. </dd></dl>

</div>
</div>
<a class="anchor" id="a134740fc5303103620fb8505696378a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnSpectatorConnect) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when a HLTV spectator has connected. </p>

</div>
</div>
<a class="anchor" id="af9fdb409f2e4b035d4fb1e70422051fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnSpectatorDisconnect) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when a HLTV spectator has disconnected. </p>

</div>
</div>
<a class="anchor" id="aa62dd8106bec6cdf940d15c26dad1327"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnSpectatorThink) (<a class="el" href="structedict__t.html">edict_t</a> *pEntity)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when a HLTV spectator's think function has to run. </p>

</div>
</div>
<a class="anchor" id="ae8457dcd0bd1cb3f21e6cfddfd86d2f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnStartFrame) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called at the start of a server game frame. </p>

</div>
</div>
<a class="anchor" id="acfe5f60070b59879cf2fc32ba9cec134"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnSys_Error) (const char *error_string)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notify game .dll that engine is going to shut down. Allows mod authors to set a breakpoint. </p>

</div>
</div>
<a class="anchor" id="a94a7fb37893394dca296b6052ed7a9a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnThink) (<a class="el" href="structedict__t.html">edict_t</a> *pEnt)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to run this entity's think function. </p>

</div>
</div>
<a class="anchor" id="abdaacb882674b044fd6b4d1689e15436"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnTouch) (<a class="el" href="structedict__t.html">edict_t</a> *pEntTouched, <a class="el" href="structedict__t.html">edict_t</a> *pEntOther)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to run pEntTouched's Touch function with pEntOther as the other entity. </p>

</div>
</div>
<a class="anchor" id="a9baea41941a3cf5a639a19d8eeb4a3f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnUpdateClientData) (const <a class="el" href="structedict__t.html">edict_t</a> *pClient, int sendweapons, <a class="el" href="structclientdata__t.html">clientdata_t</a> *cd)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the given client's data. This function can be used to implement first person observer views. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pClient</td><td>Client. </td></tr>
    <tr><td class="paramname">sendweapons</td><td>Boolean indicating whether weapon data should be sent. </td></tr>
    <tr><td class="paramname">cd</td><td>Client data to send. This is zeroed before the call to this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c828f92a56f41037e3e54b73380d55f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* DLL_FUNCTIONS::pfnUse) (<a class="el" href="structedict__t.html">edict_t</a> *pEntUsed, <a class="el" href="structedict__t.html">edict_t</a> *pEntOther)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by the engine to trigger pEntUsed's Use function, using pEntOther as the activator and caller. Obsolete. This is never called by the engine. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>engine/<a class="el" href="eiface_8h_source.html">eiface.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="struct_d_l_l___f_u_n_c_t_i_o_n_s.html">DLL_FUNCTIONS</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
